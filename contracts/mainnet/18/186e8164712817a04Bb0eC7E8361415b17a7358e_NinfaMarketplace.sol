/*----------------------------------------------------------*|
|*          ███    ██ ██ ███    ██ ███████  █████           *|
|*          ████   ██ ██ ████   ██ ██      ██   ██          *|
|*          ██ ██  ██ ██ ██ ██  ██ █████   ███████          *|
|*          ██  ██ ██ ██ ██  ██ ██ ██      ██   ██          *|
|*          ██   ████ ██ ██   ████ ██      ██   ██          *|
|*----------------------------------------------------------*/

// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import "./utils/Counters.sol";
import "./utils/RoyaltyEngineV1.sol";
import "./access/AccessControl.sol";

/*************************************************************
 * @title NinfaMarketplace                                   *
 *                                                           *
 * @notice On-chain NFT marketplace                          *
 *                                                           *
 * @custom:security-contact [email protected]                    *
 ************************************************************/

contract NinfaMarketplace is AccessControl, RoyaltyEngineV1 {
    /*----------------------------------------------------------*|
    |*  # VARIABLES                                             *|
    |*----------------------------------------------------------*/

    using Counters for Counters.Counter;
    Counters.Counter private _orderCount; // orders counter
    Counters.Counter private _offerCount; // offers counter
    address private _feeAccount; // Multisig contract that receives fees generated by the marketplace
    address private _ninfaFactory;
    uint256 private _primaryMarketOrdersFeeBps; // Ninfa Marketplace fee percentage for primary sales for orders, expressed in basis points.
    uint256 private _primaryMarketOffersFeeBps; // Ninfa Marketplace fee percentage for primary sales for offers, expressed in basis points.
    mapping(address => uint256) private _secondaryMarketFeeBps; // In order to be traded on Ninfa marketplace, collections MUST be manually approved by Ninfa's multisig contract.
    mapping(uint256 => _Order) public orders; // mapping order id to `_Order` struct.
    mapping(uint256 => _Offer) public offers; // mapping offer id to `_Offer` struct

    /*----------------------------------------------------------*|
    |*  # STRUCTS                                               *|
    |*----------------------------------------------------------*/

    /**
     * @param collection address of the ERC721 or ERC1155 contract. Doesn't require any access control besides the collection being whitelisted, i.e. msg.sender may be any address.
     * @param tokenId the NFT id, for now we only allow trading NINFA NFT's so no erc721 address is needed
     * @param unitPrice ERC-1155 unit price in ETH, or total price if ERC-721 since there is only 1 unit of each token.
     * @param erc1155Value the NFT amount, _amount == 0 for ERC721 and _amount > 0 for ERC1155
     * @param commissionReceiver receiver of commission on sales (primary AND secondary)
     * @param commissionBps commission amount, expressed in basis points 0 - 10000
     * @param operator needed in case a token operator or owner sets a payment splitter contract as the `commissionReceiver` or `seller` address respectively,
     *        an extra parameter is needed for storing the address of the token operator or owner, required for access control in case they'd want to change or cancel an order.
     * @dev therefore an additional parameter is needed to store the address of `msg.sender`
     */
    struct _Order {
        uint256 tokenId;
        uint256 unitPrice;
        uint256 erc1155Value;
        uint256 commissionBps;
        address commissionReceiver;
        address collection;
        address from;
        address operator;
    }

    struct _Offer {
        uint256 tokenId;
        uint256 unitPrice;
        uint256 erc1155Value;
        address collection;
        address from; // buyer
    }

    /*----------------------------------------------------------*|
    |*  # EVENTS                                                *|
    |*----------------------------------------------------------*/

    event OrderCreated(uint256 orderId);

    event OrderUpdated(uint256 orderId);

    event OrderDeleted(uint256 orderId);

    event OfferCreated(uint256 offerId);

    event OfferUpdated(uint256 offerId);

    event OfferDeleted(uint256 offerId);

    event CollectionWhitelisted(
        address collection,
        uint256 secondaryMarketFeeBps
    );

    event Trade(
        address indexed collection,
        uint256 indexed tokenId,
        address indexed from, // seller
        uint256 id, // we have order/offer id and all the related data stored in db.
        uint256 price,
        uint256 erc1155Value
    );

    /*----------------------------------------------------------*|
    |*  # MODIFIERS                                             *|
    |*----------------------------------------------------------*/

    /**
     * @notice ERC721 and ERC1155 collections must be whitelisted.
     * @dev if the collection has not been whitelisted, check if it is one of Ninfa's factory clones (Ninfa's self-sovreign collections)
     * @dev by checking the whitelist first with nested `if`s avoids having to make an external call unnecessarily
     */
    modifier isWhitelisted(address _collection) {
        if (_secondaryMarketFeeBps[_collection] == 0) {
            (, bytes memory authorized) = _ninfaFactory.staticcall(
                abi.encodeWithSelector(0xf6a3d24e, _collection) // function selector: 0xf6a3d24e or bytes4(keccak256("exists(address)"));
            );
            if (abi.decode(authorized, (bool)) == false) revert Unauthorized();
        }
        _;
    }

    /*----------------------------------------------------------*|
    |*  # ORDERS                                                *|
    |*----------------------------------------------------------*/

    /**
     * @notice create a new order on the marketplace by transfering an NFT to it.
     * @dev Will create a new order by sending tokens with data bytes containing function parameters
     *
     * Require:
     *
     * - can only be called by an NFT smart contract transfering an NFT to the marketplace
     * - collection must be whitelisted
     *
     */
    function _createOrder(
        address _operator, //  either the previous owner or operator, i.e. whichever address called safeTransferFrom on the ERC1155 contract
        address _from, // previous owner, i.e. seller
        uint256 _id,
        uint256 _value,
        uint256 _unitPrice,
        uint256 _commissionBps,
        address _commissionRecipient
    ) private isWhitelisted(msg.sender) {
        // `_orderCount` starts at 1
        _orderCount.increment();
        uint256 _orderId = _orderCount.current();

        // create order with new `_orderId` in orders mapping
        orders[_orderId] = _Order(
            _id,
            _unitPrice,
            _value,
            _commissionBps,
            _commissionRecipient,
            msg.sender, // collection
            _from,
            _operator
        );
        emit OrderCreated(_orderId);
    }

    //only for 1155 for updating the price and LOWER the amount
    function updateOrder(
        uint256 _erc1155RedeemAmount,
        uint256 _unitPrice,
        uint256 _orderId
    ) external {
        lowerOrderErc1155Amount(_orderId, _erc1155RedeemAmount);

        orders[_orderId].unitPrice = _unitPrice;
    }

    /**
     * @notice cancels order and transfers NFT back to owner
     * @param _orderId the Id of the order
     * @dev delete `orders[_orderId]` from storage BEFORE making external calls for transfering the NFT back to the seller (check-effects pattern)
     *
     *
     * SHOULD:
     *
     * This function does not check whether the order exists or not
     *
     */
    function deleteOrder(uint256 _orderId) external {
        _Order memory order = orders[_orderId];
        require(msg.sender == order.operator);

        delete orders[_orderId];

        _transferNFT(
            order.collection,
            address(this),
            msg.sender,
            order.tokenId,
            order.erc1155Value
        );

        emit OrderDeleted(_orderId);
    }

    /**
     * @param _unitPrice will override the old price, note that it may be 0 although this could only mean that a mistake was made
     * @dev this function doesn't enforce a positive value for `_unitPrice` in order to save a little gas for the users.
     * @dev if `_unitPrice` is set to 0, the order will be deleted from the database (not from the smart contract), see {NinfaMarketplace-OrderUpdated} modifier
     */
    function updateOrderPrice(uint256 _orderId, uint256 _unitPrice) external {
        _Order storage order = orders[_orderId];
        require(msg.sender == order.operator);

        order.unitPrice = _unitPrice;

        emit OrderUpdated(_orderId);
    }

    /**
     * @notice function to lower an order's amount of the ERC-1155 tokenId on sale, doesn't apply to ERC-721 because it is non-fungible
     * @param _erc1155RedeemAmount is the (negative) difference of tokens to be withdrawn by the seller. Should be different from 0, although not strictly required.
     */
    function lowerOrderErc1155Amount(
        uint256 _orderId,
        uint256 _erc1155RedeemAmount
    ) public {
        _Order storage order = orders[_orderId];
        require(msg.sender == order.operator);

        /// @dev warning, make changes to storage BEFORE making external calls for transfering the NFT back to the seller (check-effects-interactions pattern)
        order.erc1155Value -= _erc1155RedeemAmount;

        (bool success, ) = order.collection.call(
            abi.encodeWithSelector(
                0xf242432a, // bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a
                address(this),
                msg.sender,
                order.tokenId,
                _erc1155RedeemAmount,
                ""
            )
        );
        require(success);

        if (order.erc1155Value == 0) {
            delete orders[_orderId]; // it is not possible to delete using storage pointers https://docs.soliditylang.org/en/develop/types.html#data-location
            emit OrderDeleted(_orderId);
        } else {
            emit OrderUpdated(_orderId);
        }
    }

    /*----------------------------------------------------------*|
    |*  # OFFERS                                                *|
    |*----------------------------------------------------------*/

    /**
     * @dev offers can be made independently of whether the token is on sale or not, the msg.value is used to determine the offer amount, so no function parameter is needed for that
     * @dev there is no require to check that an offer or offer doesn't already exist and if so, that the offer amount is not greater than the order itself, this was omitted in order to save gas; the frontend should check this in order to prevent mistakes from the user
     * @param _collection address of the erc721 implementation contract or proxy contract
     * @param _tokenId the token Id to make an offer to
     * @param _amount the NFT amount, _amount == 0 for ERC721 and _amount > 0 for ERC1155
     * @param _from needed in order to integrate Wert payment solution, because in every txn Wert is the `msg.sender`.
     *      using _msgSender does not represent a security risk, on the other hand, it is possible for the buyer to use this parameter simply in order to transfer the NFT to an address other than their own, this can be useful for external contract buying NFTs.
     */
    function createOffer(
        address _collection,
        uint256 _tokenId,
        uint256 _amount,
        address _from,
        uint256 _unitPrice
    ) external payable isWhitelisted(_collection) {
        _offerCount.increment(); // start count at 1
        // this has been added in order to avoid division when calculating how much should the marketplace pay a seller for accepting this offer
        require(
            msg.value == _unitPrice * _amount ||
                (_amount == 0 && msg.value == _unitPrice)
        );

        offers[_offerCount.current()] = _Offer(
            _tokenId, // uint256 tokenId;
            _unitPrice, // uint256 unitPrice;
            _amount, // uint256 amount;
            _collection, // address collection;
            _from // address from;
        );

        emit OfferCreated(_offerCount.current());
    }

    /**
     * @dev cancels offer and refunds ETH back to bidder. When an order gets filled, the offer isn't marked as cancelled, in order to allow users to claim back their money.
     * @param _offerId the Id of the offer.
     */
    function deleteOffer(uint256 _offerId) external {
        // in memory copy needed so that it is possible to delete the struct inside the storage offers mapping, while keeping check effects interact pattern intact
        _Offer memory offer = offers[_offerId];

        uint256 refund;

        if (offer.erc1155Value == 0) {
            refund = offer.unitPrice;
        } else {
            refund = offer.unitPrice * offer.erc1155Value;
        }
        require(msg.sender == offer.from);
        // mark offer as cancelled forever, updating offer price before external call, Checks Effects Interactions pattern
        delete offers[_offerId];
        // transfer the offer amount back to bidder
        _sendValue(offer.from, refund);

        emit OfferDeleted(_offerId);
    }

    /**
     * @dev this is one of two functions called by a buyer in order to modify their offer, there are two functions, `raiseOffer()` and `lowerOffer()`, because they expect different parameters depending on whether the offer is being raised or lowerd.
     *      A `msg.value` is required, this function will add the amount sent to the old offer amount. The frontend needs to calculate the difference between the old and new offer.
     *      E.g. A buyer calls createOffer() and pays 0.1 ETH. The same buyer later wants to raise the offer to 0.3 ETH, therefore they now need to send 0.2 ETH, because 0.1 was was sent before.
     * @dev anyone can call this function, i.e. requiring that caller is offer creator is not needed
     * @param _offerId the id of the offer
     * call this function only if the new total price is greater than the old total price
     */
    function raiseOfferPrice(
        uint256 _offerId,
        uint256 _erc1155Value,
        uint256 _unitPrice
    ) external payable {
        _Offer storage _offer = offers[_offerId];

        require(
            msg.sender == _offer.from &&
                (msg.value ==
                    (_unitPrice * _erc1155Value) -
                        (_offer.unitPrice * _offer.erc1155Value) ||
                    (_erc1155Value == 0 &&
                        msg.value == _unitPrice - _offer.unitPrice))
        );

        _offer.unitPrice = _unitPrice; // transfer extra amount needed on top of older offer
        _offer.erc1155Value = _erc1155Value;

        emit OfferUpdated(_offerId);
    }

    /**
     * @dev this is one of two functions called by a buyer in order to modify their offer, there are two functions, `raiseOffer()` and `lowerOffer()`, because they expect different parameters depending on whether the offer is being raised or lowerd.
     *      In contrast with `raiseOffer()`, instead of `msg.value` this function expects a uint parameter representing the new (lower) offer; the buyer will get refunded the difference.
     *      E.g. A buyer calls createOffer() and pays 0.3 ETH. The same buyer later wants to lower the offer to 0.1 ETH, therefore they will get refunded 0.2 ETH. I.e. The amount expected by the `_newAmount` paramer is 0.1 ETH (1^17).
     * @param _offerId the id of the offer
     */
    function lowerOfferPrice(
        uint256 _offerId,
        uint256 _erc1155Amount,
        uint256 _unitPrice
    ) external {
        _Offer storage _offer = offers[_offerId];

        require(msg.sender == _offer.from);

        uint256 refund;

        if (_erc1155Amount == 0) {
            refund = _offer.unitPrice - _unitPrice;
        } else {
            refund =
                (_offer.unitPrice * _offer.erc1155Value) -
                (_unitPrice * _erc1155Amount);
            _offer.erc1155Value = _erc1155Amount;
        }

        _offer.unitPrice = _unitPrice; // needed to store result before offer price is updated
        // transfer the difference between old and new lower offer to the user
        _sendValue(msg.sender, refund);

        emit OfferUpdated(_offerId);
    }

    function acceptListedTokenOffer(
        uint256 _orderId,
        uint256 _offerId,
        uint256 _commissionBps,
        address _commissionRecipient
    ) external {
        _Order memory order = orders[_orderId];
        _Offer memory offer = offers[_offerId];

        require(
            order.operator == msg.sender &&
                order.tokenId == offer.tokenId &&
                order.collection == offer.collection
        );

        delete orders[_orderId];
        delete offers[_offerId];

        _trade(
            _Order(
                order.tokenId, // uint256 tokenId
                offer.unitPrice, // offer price, not order price
                0,
                _commissionBps, // uint256 commissionBps
                _commissionRecipient,
                order.collection, // address collection
                msg.sender, // seller
                offer.from // buyer / nft recipient
            ),
            _orderId,
            _primaryMarketOffersFeeBps
        );
    }

    /*----------------------------------------------------------*|
    |*  # TRADING                                               *|
    |*----------------------------------------------------------*/

    /**
     * @notice the collector calls this function to buy an NFT at the ask price, only if an order exists
     * @notice if someone has an open offer but calls fillOrder, the offer will remain open, meaning they will need to call cancelOffer() to get a refund. This is unlikely, as users will likely be aware of this and use the refund in order to pay for part of the order.
     * @param _id avoids having to store a mapping to order id like the deprecated `mapping(address => mapping(uint256 => uint256)) private _tokenToOrderId` which would have not worked for erc1155 as each token has a supply.
     * _orderId does not constitute a vulnerability as it is user provided, since A) a regular user will go through the frontend which gets orderId from events
     * @param _buyer needed in order to integrate Wert payment solution, because in every txn Wert is the msg.sender, although using msg.sender would cost less gas.
     * using _msgSender does not represent a security risk, on the other hand, it is possible for the buyer to use this parameter simply in order to transfer the NFT to an address other than their own, this can be useful for external contract buying NFTs.
     + @param _erc1155Value market order amount (total or partial fill).
     * `_erc1155Value == 0` corresponds to one erc721 tokenId, `_erc1155Value > 0` for erc1155 tokenIds
     *
     * MUST:
     *
     * - `msg.value` must be equal to `orders[_orderId]der.unitPrice * buyAmount`
     * - `orders[_orderId].sellAmount >= buyAmount`
     *
     */
    function fillOrder(
        uint256 _id,
        address _buyer,
        uint256 _erc1155Value
    ) external payable {
        _Order memory order = orders[_id];

        require(
            msg.value ==
                order.unitPrice * (_erc1155Value == 0 ? 1 : _erc1155Value)
        );

        // subtracting user-suplied `_erc1155Value` from order amount, transaction will revert if underflow, implicitly requiring `orders[_id]._erc1155Value >= _erc1155Value`
        if (orders[_id].erc1155Value - _erc1155Value == 0) delete orders[_id];
        else orders[_id].erc1155Value -= _erc1155Value;

        _trade(
            _Order(
                order.tokenId, // uint256 tokenId
                msg.value, // price
                _erc1155Value,
                order.commissionBps, // uint256 commissionBps
                order.commissionReceiver, // address commissionReceiver
                order.collection, // address collection
                order.from, // seller or from
                _buyer // address buyer used for nft transfer
            ),
            _id,
            _primaryMarketOrdersFeeBps // uint256 primaryFee
        );
    }

    /**
     *
     * @dev Handles the receipt of a single ERC1155 token type. This function is
     * called at the end of a `safeTransferFrom` after the balance has been updated.
     *
     * NOTE: To accept the transfer, this must return
     * `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`
     * (i.e. 0xf23a6e61, or its own function selector).
     *
     * @param _operator The address which initiated the transfer (i.e. msg.sender)
     * @param _from     The address which previously owned the token
     * @param _tokenId  The ID of the token being transferred
     * @param _value    The amount of tokens being transferred
     * @param _data     Additional data with no specified format
     * @param _data     `uint256 id` corresponding to an order to be updated or an offer to be accepted, if the `id` parameter is 0 create a new order.
     * @param _data     `uint256 unitPrice` is only required for updating an order, i.e. if `unitPrice == 0` `id` an offer id, if `unitPrice > 0` `id` is an order id
     * @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed
     */
    function onERC1155Received(
        address _operator, //  either the previous owner or operator, whoever called safeTransferFrom on the ERC1155 contract
        address _from, // previous owner
        uint256 _tokenId,
        uint256 _value,
        bytes memory _data
    ) external returns (bytes4) {
        (
            uint256 id,
            uint256 unitPrice,
            uint256 commissionBps,
            address commissionReceiver
        ) = abi.decode(_data, (uint256, uint256, uint256, address));

        if (unitPrice == 0) {
            /*----------------------------------------------------------*|
            |*  # ACCEPT OFFER                                          *|
            |*----------------------------------------------------------*/
            // if `_value` is more than the amount the following if check will revert due to underflow,
            // intended to stop someone from sending more erc1155 tokens then there are available in the order

            _Offer memory offer = offers[id];

            require(
                offer.collection == msg.sender && offer.tokenId == _tokenId
            );

            // subtracting `_value` from offer amount, transaction will revert if underflow, implicitly requiring `offers[id]._erc1155Value >= _value`
            if (offers[id].erc1155Value - _value == 0) delete offers[id];
            else offers[id].erc1155Value -= _value;

            _trade(
                _Order(
                    _tokenId, // uint256 tokenId
                    offer.unitPrice * _value, // uint256 price (unitPrice * value)
                    _value,
                    commissionBps, // uint256 commissionBps
                    commissionReceiver, // address commissionReceiver
                    msg.sender, // address collection
                    _from, // seller
                    offer.from // buyer or operator
                ),
                id,
                _primaryMarketOffersFeeBps
            );
        } else if (id == 0) {
            /*----------------------------------------------------------*|
            |*  # CREATE ORDER                                          *|
            |*----------------------------------------------------------*/
            // if the order/offer id parameter is 0, create a new order

            _createOrder(
                _operator,
                _from,
                _tokenId,
                _value,
                unitPrice,
                commissionBps,
                commissionReceiver
            );
        } else {
            /*----------------------------------------------------------*|
            |*  # UPDATE ORDER                                          *|
            |*----------------------------------------------------------*/
            // if the user supplied a non-zero value for `unitPrice` then the `id` parameter must correspond to an order that needs to be updated
            // the operator, collection and tokenId of the NFT received by the marketplace must match the ones stored at the id provided by the operator
            // in order to avoid operators increasing allowance for orders with different (more valuable) NFTs
            _Order storage order = orders[id];

            require(
                order.operator == _operator &&
                    order.collection == msg.sender &&
                    order.tokenId == _tokenId
            );
            order.erc1155Value += _value;
            order.unitPrice = unitPrice;

            emit OrderUpdated(id);
        }

        return 0xf23a6e61;
    }

    /**
     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
     * by `operator` from `from`, this function is called.
     *
     * It must return its Solidity selector to confirm the token transfer.
     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
     *
     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.
     * @param _operator The address which called `safeTransferFrom` function
     * @param _from The address which previously owned the token
     * @param _tokenId The NFT identifier which is being transferred
     * @param _data Additional data with no specified format
     */
    function onERC721Received(
        address _operator,
        address _from,
        uint256 _tokenId,
        bytes calldata _data
    ) external returns (bytes4) {
        (
            uint256 id,
            uint256 unitPrice,
            uint256 commissionBps,
            address commissionReceiver
        ) = abi.decode(_data, (uint256, uint256, uint256, address));

        if (id == 0) {
            /*----------------------------------------------------------*|
            |*  # CREATE ORDER                                          *|
            |*----------------------------------------------------------*/
            // if the order/offer id parameter is 0, create a new order
            _createOrder(
                _operator,
                _from,
                _tokenId,
                0,
                unitPrice,
                commissionBps,
                commissionReceiver
            );
        } else {
            /*----------------------------------------------------------*|
            |*  # ACCEPT OFFER                                          *|
            |*----------------------------------------------------------*/
            // if `_value` is more than the amount the following if check will revert due to underflow,
            // intended to stop someone from sending more erc1155 tokens then there are available in the order
            _Offer memory offer = offers[id];

            require(
                offer.collection == msg.sender && offer.tokenId == _tokenId
            );

            delete offers[id]; // ERC-721 doesn't have any supply therefore the offer may be deleted after accepting the offer

            _trade(
                _Order(
                    _tokenId, // uint256 tokenId
                    offer.unitPrice, // uint256 price
                    0,
                    commissionBps, // uint256 commissionBps
                    commissionReceiver,
                    msg.sender, // address collection
                    _from, // address buyer or from
                    offer.from // seller
                ),
                id,
                _primaryMarketOffersFeeBps //uint256 primaryFee
            );
        }

        return 0x150b7a02;
    }

    function _transferNFT(
        address _collection,
        address _from,
        address _to,
        uint256 _tokenId,
        uint256 _erc1155Value
    ) private {
        bool success;
        if (_erc1155Value == 0)
            (success, ) = _collection.call(
                abi.encodeWithSelector(
                    0x42842e0e, // bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e
                    _from,
                    _to,
                    _tokenId
                )
            );
        else
            (success, ) = _collection.call(
                abi.encodeWithSelector(
                    0xf242432a, // bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a
                    _from,
                    _to,
                    _tokenId,
                    _erc1155Value,
                    ""
                )
            );

        require(success);
    }

    /**
     * param _buyer order or offer creator, depending on who `msg.sender` is
     * param _price NFT's price
     * param _tokenId NFT's Id
     *
     * @dev the check-effects-interactions pattern is not fully applied although this is not a security issue;
     *  the first external untrusted call is to the royalties receiver address, however reentrancy is not an issue as all global state variables have already been set at that point, and subsequent state changes only affect local function variables that cannot be modified by reentering the contract.
     *  ETH transfers (external calls) are paid out in this order: royalties receiver (if any), marketplace fees receiver, commissions receiver (if any) , seller
     *  The worst case is that royalty receiver of an external collection sets royalties bps equal to price - fees in order to receive/steal the entire seller's profit. Arguably this would harm the artist, given Ninfa is a curated marketplace, that is why we accept this risk.
     *
     * Requires:
     *
     * - Requires that `(royaltyAmount +  marketplaceAmount + _commissionBps) < _order.unitPrice`.
     *
     */
    function _trade(
        _Order memory _order,
        uint256 _id,
        uint256 _primaryMarketFeeBps
    ) private {
        uint256 royaltyAmount;
        uint256 marketplaceAmount; // declare `marketplaceAmount`, its value will be calculated based on whether it is a primary or secondary sale
        uint256 commissionAmount;
        if (_order.commissionBps > 0)
            commissionAmount =
                (_order.commissionBps * _order.unitPrice) /
                10000; // calculate commission amount
        uint256 sellerAmount = _order.unitPrice; // sellerAmount is set equal to price and reduced at each step by subtracting fees, royalties and commissions, if any.
        // `getRoyalty()` is a getter function from a modified implementation of `RoyaltyEngineV1`, it only checks that `royaltyAmount < price`.
        // arrays are returned so that their length may be checked before accessing their elements at index 0; an empty array is returned when royalties are not supported.
        (
            address payable[] memory royaltyRecipients,
            uint256[] memory royaltyAmounts
        ) = getRoyalty(_order.collection, _order.tokenId, _order.unitPrice);

        if (royaltyAmounts.length > 0) {
            /*----------------------------------------------------------*|
            |*  # IF ROYALTIES SUPPORTED                                *|
            |*----------------------------------------------------------*/
            // The collection implements some royalty standard, otherwise the length of the arrays returned would be 0.

            royaltyAmount = royaltyAmounts[0];

            if (royaltyAmount == 0) {
                /*----------------------------------------------------------*|
                |*  # IF PRIMARY MARKET (NINFA'S ERC-721 COLLECTIONS)       *|
                |*----------------------------------------------------------*/
                // If the array has a length and AND the content of `royaltyAmount` equals 0, the collection has
                // explicitly implemented royalties and set them to 0, i.e. it is a primary sale.
                // > "Marketplaces that support this standard SHOULD NOT send a zero-value transaction if the royaltyAmount returned is 0." https://eips.ethereum.org/EIPS/eip-2981

                marketplaceAmount =
                    (_order.unitPrice * _primaryMarketFeeBps) /
                    10000;
            } else {
                /*----------------------------------------------------------*|
                |*  # IF SECONDARY MARKET                                   *|
                |*----------------------------------------------------------*/
                //  `_secondaryMarketFeeBps[_ninfaFactory]` is used as a fees BPS placeholder for all Ninfa self sovereign erc1155 collections.
                //  if it can't be found in the _secondaryMarketFeeBps (whitelist) then it must be one of Ninfa's communal collections (721 or 1155).
                //  Ninfa factory clones, defaults to whatever bps stored at address(0) that is used as placeholder, currently 500 or 5%.

                /*----------------------------------------------------------*|
                |*  # PAY ROYALTIES                                         *|
                |*----------------------------------------------------------*/
                // > "Marketplaces that support this standard MUST pay royalties no matter where the sale occurred or in what currency" - https://eips.ethereum.org/EIPS/eip-2981.

                sellerAmount -= royaltyAmount; // subtract before external call.
                _sendValue(royaltyRecipients[0], royaltyAmount);

                /*----------------------------------------------------------*|
                |*  # CALCULATE MARKETPLACE FEE AMOUNT                      *|
                |*----------------------------------------------------------*/

                marketplaceAmount =
                    (_order.unitPrice *
                        (
                            _secondaryMarketFeeBps[_order.collection] > 0
                                ? _secondaryMarketFeeBps[_order.collection] // NINFA_ERC721_V2 or any external whitelisted collection
                                : _secondaryMarketFeeBps[_ninfaFactory]
                        )) /
                    10000;
            }
        }

        /*----------------------------------------------------------*|
        |*  # PAY MARKETPLACE FEE                                   *|
        |*----------------------------------------------------------*/

        // subtracting primary or secondary fee amount from seller amount, this is a security check (will revert on underflow) as well as a variable assignment.
        sellerAmount -= marketplaceAmount; // subtract before external call.

        _sendValue(_feeAccount, marketplaceAmount);

        /*----------------------------------------------------------*|
        |*  # PAY ORDER COMMISSIONS (if any)                         *|
        |*----------------------------------------------------------*/
        //TODO: calculate commission amount based on price and commission bps
        if (commissionAmount > 0) {
            sellerAmount -= commissionAmount;
            _sendValue(_order.commissionReceiver, commissionAmount);
        }

        /*----------------------------------------------------------*|
        |*  # PAY SELLER                                            *|
        |*----------------------------------------------------------*/
        _sendValue(_order.from, sellerAmount);

        _transferNFT(
            _order.collection,
            address(this),
            _order.operator, // buyer
            _order.tokenId,
            _order.erc1155Value
        );

        emit Trade(
            _order.collection,
            _order.tokenId,
            _order.from, // seller
            _id,
            _order.unitPrice,
            _order.erc1155Value
        );
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `_amount` wei to
     * `_receiver`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] raises the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {_sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `_receiver`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function _sendValue(address _receiver, uint256 _amount) private {
        // solhint-disable-next-line avoid-low-level-calls
        (bool success, ) = payable(_receiver).call{value: _amount}("");
        require(success);
    }

    /*----------------------------------------------------------*|
    |*  # ONLY ADMIN                                            *|
    |*----------------------------------------------------------*/

    /**
     * @notice setter function only callable by contract admin used to change any or all addresses used by the Marketplace,
     * @dev if only one address needs to be set, make sure you are passing all other past addresses as parameters, i.e. not changing any of the other addresses' preveious value.
     * @dev the reason there is only one setter function rather many is to save bytecode, because the Marketplace is very close to contract size limit
     * @param feeAccount_ is the address owned by NINFA that will collect sales fees
     */
    function setAdminContracts(
        address feeAccount_,
        address ninfaFactory_
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        // set address for receiving marketplace fees
        _feeAccount = feeAccount_;
        // set address of ERC1155 factory
        _ninfaFactory = ninfaFactory_;
    }

    /**
     * @notice whitelist collection to be traded on marketplace
     * @dev this function needs to be called immediately after deployment in order to set marketplace fees for NINFA_ERC721_V2 to 500bps or 5%. Required for access control by `isWhitelisted` modifier, also required in order to set secondary sales fees for NINFA_ERC721_V2 and all NinfaERC1155 to 5%.
     * @param _collection address of collection ERC721 or ERC1155
     * address(0) is used as a placeholder to store secondary fees amount for Ninfa's self-sovreign collections, as a matter of fact,
     * _collection calling this function and setting collection fees for address(0) is the only way there is in order to change secondary fees for all of Ninfa's self sovreign collections
     * in order to set or reset secondary fees for Ninfa's communal collections or any other, this function must be called for every collection that requires changing fees
     * this can be tedious and expensive but it allows to set fine-grained fees on a per-collection basis
     * @param secondaryMarketFeeBps_ adds a uint to a mapping, if uint is positive the isWhitelisted modifier will return true, the uint corresponds to the secondary fee basis points, the maximum should be < 8501.
     */
    function whitelistCollection(
        address _collection,
        uint256 secondaryMarketFeeBps_
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _secondaryMarketFeeBps[_collection] = secondaryMarketFeeBps_;

        emit CollectionWhitelisted(_collection, secondaryMarketFeeBps_);
    }

    /**
     * @notice sets primary sale fees for NINFA_ERC721_V2 communal collection.
     * @dev primary fees may be 0%, this is the default when not set.
     */
    function setPrimaryMarketFeeBps(
        uint256 primaryMarketOrdersFeeBps_,
        uint256 primaryMarketOffersFeeBps_
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _primaryMarketOrdersFeeBps = primaryMarketOrdersFeeBps_;
        _primaryMarketOffersFeeBps = primaryMarketOffersFeeBps_;
    }

    /*----------------------------------------------------------*|
    |*  # VIEW FUNCTIONS                                        *|
    |*----------------------------------------------------------*/

    /**
     * @dev See {IERC165-supportsInterface}.
     * @dev supportsInterface is only needed to signal support for onERC1155Received, not onERC721Received. The interface is probably needed because a contract may implement onERC1155Received, onERC1155BatchReceived, or both. See https://forum.openzeppelin.com/t/erc721holder-ierc721receiver-and-onerc721received/11828
     */
    function supportsInterface(
        bytes4 interfaceId
    ) external pure returns (bool) {
        return
            interfaceId == 0x01ffc9a7 || // Interface ID for IERC165
            interfaceId == 0xf23a6e61; // Return value from `onERC1155Received` call if a contract accepts receipt (i.e `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`).
        // todo interfaceId == 0x150b7a02; // Interface ID for IERC721Receiver
    }

    function setOrderCommission(
        uint256 _orderId,
        uint256 _commissionBps,
        address _commissionRecipient
    ) external {
        require(msg.sender == orders[_orderId].operator);
        orders[_orderId].commissionBps = _commissionBps;
        orders[_orderId].commissionReceiver = _commissionRecipient;
        emit OrderUpdated(_orderId);
    }

    /*----------------------------------------------------------*|
    |*  # CONSTRUCTOR                                           *|
    |*----------------------------------------------------------*/

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`
     * @dev after deployment need to manually call setAddresses.
     * @param _royaltyRegistry see https://royaltyregistry.xyz/lookup for public addresses
     * @param primaryMarketOffersFeeBps_ is set to 500 BPS (5% shares) at deployment and is used for secondary market fees (`_secondaryMarketFeeBps`) also.
     * @param ninfaFactory_ is used as a placeholder to store secondary fees BPS for all of Ninfa's self-sovreign ERC-721 and ERC-1155 collections
     */
    constructor(
        address _royaltyRegistry,
        address _ninfaERC721v1,
        address _ninfaERC721v2,
        address _ninfaERC1155,
        address feeAccount_,
        address ninfaFactory_,
        uint256 primaryMarketOrdersFeeBps_,
        uint256 primaryMarketOffersFeeBps_
    ) RoyaltyEngineV1(_royaltyRegistry) {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);

        _feeAccount = feeAccount_;
        _ninfaFactory = ninfaFactory_;

        _secondaryMarketFeeBps[_ninfaERC721v1] = primaryMarketOffersFeeBps_;
        emit CollectionWhitelisted(_ninfaERC721v1, primaryMarketOffersFeeBps_);
        _secondaryMarketFeeBps[_ninfaERC721v2] = primaryMarketOffersFeeBps_;
        emit CollectionWhitelisted(_ninfaERC721v2, primaryMarketOffersFeeBps_);
        _secondaryMarketFeeBps[_ninfaERC1155] = primaryMarketOffersFeeBps_;
        emit CollectionWhitelisted(_ninfaERC1155, primaryMarketOffersFeeBps_);

        _secondaryMarketFeeBps[_ninfaFactory] = primaryMarketOffersFeeBps_;
        emit CollectionWhitelisted(_ninfaFactory, primaryMarketOffersFeeBps_);

        _primaryMarketOrdersFeeBps = primaryMarketOrdersFeeBps_;
        _primaryMarketOffersFeeBps = primaryMarketOffersFeeBps_;
    }
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.17;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

library SuperRareContracts {
    address internal constant SUPERRARE_REGISTRY =
        0x17B0C8564E53f22364A6C8de6F7ca5CE9BEa4e5D;
    address internal constant SUPERRARE_V1 =
        0x41A322b28D0fF354040e2CbC676F0320d8c8850d;
    address internal constant SUPERRARE_V2 =
        0xb932a70A57673d89f4acfFBE830E8ed7f75Fb9e0;
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)

pragma solidity 0.8.17;

/**
 * @dev String operations.
 */
library Strings {
    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        // Inspired by OraclizeAPI's implementation - MIT licence
        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0x00";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(uint256 value, uint256 length)
        internal
        pure
        returns (string memory)
    {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }
}

/*----------------------------------------------------------*|
|*          ███    ██ ██ ███    ██ ███████  █████           *|
|*          ████   ██ ██ ████   ██ ██      ██   ██          *|
|*          ██ ██  ██ ██ ██ ██  ██ █████   ███████          *|
|*          ██  ██ ██ ██ ██  ██ ██ ██      ██   ██          *|
|*          ██   ████ ██ ██   ████ ██      ██   ██          *|
|*----------------------------------------------------------*/

// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import "./SuperRareContracts.sol";
import "../specs/IRoyaltyRegistry.sol";
import "../specs/IManifold.sol";
import "../specs/IRarible.sol";
import "../specs/IFoundation.sol";
import "../specs/ISuperRare.sol";
import "../specs/IEIP2981.sol";
import "../specs/IZoraOverride.sol";
import "../specs/IArtBlocksOverride.sol";
import "../specs/IKODAV2Override.sol";

/*************************************************************
 * @title RoyaltyEngineV1                                    *
 *                                                           *
 * @notice Custom implementation of Manifold RoyaltyEngineV1 *
 *                                                           *
 * @dev > "Marketplaces may choose to directly inherit the   *
 * Royalty Engine to save a bit of gas".                     *
 *                                                           *
 * @dev ERC165 was removed because interface selector will   *
 * be different from Manifold's (0xcb23f816) and this engine *
 * implementation is not meant for used by other contracts   *
 *                                                           *
 * @author Fork of Manifold's RoyaltyRegistryV1              *
 *                                                           *
 * @custom:security-contact [email protected]                    *
 ************************************************************/

contract RoyaltyEngineV1 {
    /**
     * @dev ROYALTY_REGISTRY could be a hardcoded constant, however using an immutable variable
     * is useful for deploying the engine onto other (test) networks where its address differs from Mainnet
     */
    address internal immutable ROYALTY_REGISTRY;

    error Unauthorized();
    error InvalidAmount(uint256 amount);
    error LengthMismatch(uint256 recipients, uint256 bps); // only used in RoyaltyEngineV1

    /**
     * Get the royalties for a given token and sale amount.
     *
     * @param tokenAddress - address of token
     * @param tokenId - id of token
     * @param value - sale value of token
     * Returns two arrays, first is the list of royalty recipients, second is the amounts for each recipient.
     */
    function getRoyalty(
        address tokenAddress,
        uint256 tokenId,
        uint256 value
    )
        internal
        view
        returns (address payable[] memory recipients, uint256[] memory amounts)
    {
        // External call to limit gas
        try
            /**
             * @dev Control-flow hijack and gas griefing vulnerability within Manifold's RoyaltyEngine.
             *      To mitigate the griefing vector and other potential vulnerabilities, limit the gas by default that _getRoyalty is given to at most 50,000 gas, but certainly no more than 100,000 gas.
             *      - https://githubrecord.com/issue/manifoldxyz/royalty-registry-solidity/17/1067105243
             */
            this._getRoyalty{gas: 100000}(tokenAddress, tokenId, value)
        returns (
            address payable[] memory _recipients,
            uint256[] memory _amounts
        ) {
            return (_recipients, _amounts);
        } catch {
            revert("Invalid royalty amount");
        }
    }

    /**
     * @dev Get the royalty for a given token
     * @dev the original RoyaltyEngineV1 has been modified by removing the _specCache and the associated code,
     * using try catch statements is very cheap, no need to store `_specCache` mapping, see {RoyaltyEngineV1-_specCache}.
     * - https://www.reddit.com/r/ethdev/comments/szot8r/comment/hy5vsxb/
     * @dev EIP-2981 standard lookup is performed first unlike Manifold's implementation, as it is the most prevalent
     * royalty standard as well as the one being used by Ninfa's collections
     * @return recipients array and amounts array, if no royalty standard has been found, the returned arrays will be empty
     */
    function _getRoyalty(
        address tokenAddress,
        uint256 tokenId,
        uint256 value
    )
        external
        view
        returns (address payable[] memory recipients, uint256[] memory amounts)
    {
        address royaltyAddress = IRoyaltyRegistry(ROYALTY_REGISTRY)
            .getRoyaltyLookupAddress(tokenAddress);

        try IEIP2981(royaltyAddress).royaltyInfo(tokenId, value) returns (
            address recipient,
            uint256 amount
        ) {
            // Supports EIP2981. Return amounts
            if (amount > value) revert InvalidAmount(amount); // note doesn't revert if amount == value
            recipients = new address payable[](1);
            amounts = new uint256[](1);
            recipients[0] = payable(recipient);
            amounts[0] = amount;
            return (recipients, amounts);
        } catch {}

        // SuperRare handling
        if (
            tokenAddress == SuperRareContracts.SUPERRARE_V1 ||
            tokenAddress == SuperRareContracts.SUPERRARE_V2
        ) {
            try
                ISuperRareRegistry(SuperRareContracts.SUPERRARE_REGISTRY)
                    .tokenCreator(tokenAddress, tokenId)
            returns (address payable creator) {
                try
                    ISuperRareRegistry(SuperRareContracts.SUPERRARE_REGISTRY)
                        .calculateRoyaltyFee(tokenAddress, tokenId, value)
                returns (uint256 amount) {
                    recipients = new address payable[](1);
                    amounts = new uint256[](1);
                    recipients[0] = creator;
                    amounts[0] = amount;
                    return (recipients, amounts);
                } catch {}
            } catch {}
        }

        try IManifold(royaltyAddress).getRoyalties(tokenId) returns (
            address payable[] memory recipients_,
            uint256[] memory bps
        ) {
            // Supports manifold interface.  Compute amounts
            if (recipients_.length != bps.length)
                revert LengthMismatch(recipients_.length, bps.length);
            return (recipients_, _computeAmounts(value, bps));
        } catch {}

        try IRaribleV2(royaltyAddress).getRaribleV2Royalties(tokenId) returns (
            IRaribleV2.Part[] memory royalties
        ) {
            // Supports rarible v2 interface. Compute amounts
            recipients = new address payable[](royalties.length);
            amounts = new uint256[](royalties.length);
            uint256 totalAmount;
            for (uint256 i = 0; i < royalties.length; i++) {
                recipients[i] = royalties[i].account;
                amounts[i] = (value * royalties[i].value) / 10000;
                totalAmount += amounts[i];
            }
            if (totalAmount > value) revert InvalidAmount(totalAmount);
            return (recipients, amounts);
        } catch {}
        try IRaribleV1(royaltyAddress).getFeeRecipients(tokenId) returns (
            address payable[] memory recipients_
        ) {
            // Supports rarible v1 interface. Compute amounts
            recipients_ = IRaribleV1(royaltyAddress).getFeeRecipients(tokenId);
            try IRaribleV1(royaltyAddress).getFeeBps(tokenId) returns (
                uint256[] memory bps
            ) {
                if (recipients_.length != bps.length)
                    revert LengthMismatch(recipients_.length, bps.length);
                return (recipients_, _computeAmounts(value, bps));
            } catch {}
        } catch {}
        try IFoundation(royaltyAddress).getFees(tokenId) returns (
            address payable[] memory recipients_,
            uint256[] memory bps
        ) {
            // Supports foundation interface.  Compute amounts
            if (recipients_.length != bps.length)
                revert LengthMismatch(recipients_.length, bps.length);
            return (recipients_, _computeAmounts(value, bps));
        } catch {}
        try
            IZoraOverride(royaltyAddress).convertBidShares(
                tokenAddress,
                tokenId
            )
        returns (address payable[] memory recipients_, uint256[] memory bps) {
            // Support Zora override
            if (recipients_.length != bps.length)
                revert LengthMismatch(recipients_.length, bps.length);
            return (recipients_, _computeAmounts(value, bps));
        } catch {}
        try
            IArtBlocksOverride(royaltyAddress).getRoyalties(
                tokenAddress,
                tokenId
            )
        returns (address payable[] memory recipients_, uint256[] memory bps) {
            // Support Art Blocks override
            if (recipients_.length != bps.length)
                revert LengthMismatch(recipients_.length, bps.length);
            return (recipients_, _computeAmounts(value, bps));
        } catch {}
        try
            IKODAV2Override(royaltyAddress).getKODAV2RoyaltyInfo(
                tokenAddress,
                tokenId,
                value
            )
        returns (
            address payable[] memory _recipients,
            uint256[] memory _amounts
        ) {
            // Support KODA V2 override
            if (_recipients.length != _amounts.length)
                revert LengthMismatch(_recipients.length, _amounts.length);
            return (_recipients, _amounts);
        } catch {}

        // No supported royalties configured
        return (recipients, amounts);
    }

    /**
     * Compute royalty amounts
     */
    function _computeAmounts(
        uint256 value,
        uint256[] memory bps
    ) private pure returns (uint256[] memory amounts) {
        amounts = new uint256[](bps.length);
        uint256 totalAmount;
        for (uint256 i = 0; i < bps.length; i++) {
            amounts[i] = (value * bps[i]) / 10000;
            totalAmount += amounts[i];
        }
        if (totalAmount > value) revert InvalidAmount(totalAmount);
        return amounts;
    }

    constructor(address _royaltyRegistry) {
        ROYALTY_REGISTRY = _royaltyRegistry;
    }
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.17;

/**
 * @title Counters
 * @dev Stripped down version of OpenZeppelin Contracts v4.4.1 (utils/Counters.sol), identical to CountersUpgradeable.sol being a library. Provides counters that can only be incremented. Used to track the total supply of ERC721 ids.
 * @dev Include with `using Counters for Counters.Counter;`
 */
library Counters {
    struct Counter {
        uint256 _value; // default: 0
    }

    function current(Counter storage counter) internal view returns (uint256) {
        return counter._value;
    }

    /// @dev if implementing ERC721A there could be an overflow risk by removing overflow protection with `unchecked`, unless we limit the amount of tokens that can be minted, or require that totalsupply be less than 2^256 - 1
    function increment(Counter storage counter) internal {
        unchecked {
            counter._value += 1;
        }
    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * Paired down version of the Zora Market interface
 */
interface IZoraMarket {
    struct ZoraDecimal {
        uint256 value;
    }

    struct ZoraBidShares {
        // % of sale value that goes to the _previous_ owner of the nft
        ZoraDecimal prevOwner;
        // % of sale value that goes to the original creator of the nft
        ZoraDecimal creator;
        // % of sale value that goes to the seller (current owner) of the nft
        ZoraDecimal owner;
    }

    function bidSharesForToken(uint256 tokenId) external view returns (ZoraBidShares memory);
}

/**
 * Paired down version of the Zora Media interface
 */
interface IZoraMedia {

    /**
     * Auto-generated accessors of public variables
     */
    function marketContract() external view returns(address);
    function previousTokenOwners(uint256 tokenId) external view returns(address);
    function tokenCreators(uint256 tokenId) external view returns(address);

    /**
     * ERC721 function
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);
}

/**
 * Interface for a Zora media override
 */
interface IZoraOverride {

    /**
     * @dev Convert bid share configuration of a Zora Media token into an array of receivers and bps values
     *      Does not support prevOwner and sell-on amounts as that is specific to Zora marketplace implementation
     *      and requires updates on the Zora Media and Marketplace to update the sell-on amounts/previous owner values.
     *      An off-Zora marketplace sale will break the sell-on functionality.
     */
    function convertBidShares(address media, uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);

}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

interface ISuperRareRegistry {
    /**
     * @dev Get the royalty fee percentage for a specific ERC721 contract.
     * @param _contractAddress address ERC721Contract address.
     * @param _tokenId uint256 token ID.
     * @return uint8 wei royalty fee.
     */
    function getERC721TokenRoyaltyPercentage(
        address _contractAddress,
        uint256 _tokenId
    ) external view returns (uint8);

    /**
     * @dev Utililty function to calculate the royalty fee for a token.
     * @param _contractAddress address ERC721Contract address.
     * @param _tokenId uint256 token ID.
     * @param _amount uint256 wei amount.
     * @return uint256 wei fee.
     */
    function calculateRoyaltyFee(
        address _contractAddress,
        uint256 _tokenId,
        uint256 _amount
    ) external view returns (uint256);

    /**
     * @dev Get the token creator which will receive royalties of the given token
     * @param _contractAddress address ERC721Contract address.
     * @param _tokenId uint256 token ID.
     */
    function tokenCreator(address _contractAddress, uint256 _tokenId)
        external
        view
        returns (address payable);
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/// @author: manifold.xyz

import "../utils/introspection/IERC165.sol";

/**
 * @dev Royalty registry interface
 */
interface IRoyaltyRegistry is IERC165 {
    event RoyaltyOverride(
        address owner,
        address tokenAddress,
        address royaltyAddress
    );

    /**
     * Override the location of where to look up royalty information for a given token contract.
     * Allows for backwards compatibility and implementation of royalty logic for contracts that did not previously support them.
     *
     * @param tokenAddress    - The token address you wish to override
     * @param royaltyAddress  - The royalty override address
     */
    function setRoyaltyLookupAddress(
        address tokenAddress,
        address royaltyAddress
    ) external returns (bool);

    /**
     * Returns royalty address location.  Returns the tokenAddress by default, or the override if it exists
     *
     * @param tokenAddress    - The token address you are looking up the royalty for
     */
    function getRoyaltyLookupAddress(
        address tokenAddress
    ) external view returns (address);

    /**
     * Returns the token address that an overrideAddress is set for.
     * Note: will not be accurate if the override was created before this function was added.
     *
     * @param overrideAddress - The override address you are looking up the token for
     */
    function getOverrideLookupTokenAddress(
        address overrideAddress
    ) external view returns (address);

    /**
     * Whether or not the message sender can override the royalty address for the given token address
     *
     * @param tokenAddress    - The token address you are looking up the royalty for
     */
    function overrideAllowed(address tokenAddress) external view returns (bool);
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

interface IRaribleV1 {
    /*
     * bytes4(keccak256('getFeeBps(uint256)')) == 0x0ebd4c7f
     * bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb
     *
     * => 0x0ebd4c7f ^ 0xb9c4d9fb == 0xb7799584
     */
    function getFeeBps(uint256 id) external view returns (uint[] memory);
    function getFeeRecipients(uint256 id) external view returns (address payable[] memory);
}


interface IRaribleV2 {
    /*
     *  bytes4(keccak256('getRaribleV2Royalties(uint256)')) == 0xcad96cca
     */
    struct Part {
        address payable account;
        uint96 value;
    }
    function getRaribleV2Royalties(uint256 id) external view returns (Part[] memory);
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/// @author: manifold.xyz

/**
 * @dev Royalty interface for creator core classes
 */
interface IManifold {

    /**
     * @dev Get royalites of a token.  Returns list of receivers and basisPoints
     *
     *  bytes4(keccak256('getRoyalties(uint256)')) == 0xbb3bafd6
     *
     *  => 0xbb3bafd6 = 0xbb3bafd6
     */
    function getRoyalties(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);
}

// SPDX-License-Identifier: MIT

/// @author: knownorigin.io

pragma solidity ^0.8.0;

interface IKODAV2 {
    function editionOfTokenId(uint256 _tokenId) external view returns (uint256 _editionNumber);

    function artistCommission(uint256 _editionNumber) external view returns (address _artistAccount, uint256 _artistCommission);

    function editionOptionalCommission(uint256 _editionNumber) external view returns (uint256 _rate, address _recipient);
}

interface IKODAV2Override {

    /// @notice Emitted when the royalties fee changes
    event CreatorRoyaltiesFeeUpdated(uint256 _oldCreatorRoyaltiesFee, uint256 _newCreatorRoyaltiesFee);

    /// @notice For the given KO NFT and token ID, return the addresses and the amounts to pay
    function getKODAV2RoyaltyInfo(address _tokenAddress, uint256 _id, uint256 _amount)
    external
    view
    returns (address payable[] memory, uint256[] memory);

    /// @notice Allows the owner() to update the creator royalties
    function updateCreatorRoyalties(uint256 _creatorRoyaltiesFee) external;
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

interface IFoundation {
    /*
     *  bytes4(keccak256('getFees(uint256)')) == 0xd5a06d4c
     *
     *  => 0xd5a06d4c = 0xd5a06d4c
     */
    function getFees(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);
}

interface IFoundationTreasuryNode {
    function getFoundationTreasury() external view returns (address payable);
}

interface IFoundationTreasury {
    function isAdmin(address account) external view returns (bool);
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * EIP-2981
 */
interface IEIP2981 {
    /**
     * bytes4(keccak256("royaltyInfo(uint256,uint256)")) == 0x2a55205a
     *
     * => 0x2a55205a = 0x2a55205a
     */
    function royaltyInfo(uint256 tokenId, uint256 value) external view returns (address, uint256);
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 *  Interface for an Art Blocks override
 */
interface IArtBlocksOverride {
    /**
     * @dev Get royalites of a token at a given tokenAddress.
     *      Returns array of receivers and basisPoints.
     *
     *  bytes4(keccak256('getRoyalties(address,uint256)')) == 0x9ca7dc7a
     *
     *  => 0x9ca7dc7a = 0x9ca7dc7a
     */
    function getRoyalties(address tokenAddress, uint256 tokenId)
        external
        view
        returns (address payable[] memory, uint256[] memory);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)

pragma solidity 0.8.17;

import "../utils/Strings.sol";

/**
 * @dev Contract module that allows children to implement role-based access
 * control mechanisms. This is a lightweight version that doesn't allow enumerating role
 * members except through off-chain means by accessing the contract event logs. Some
 * applications may benefit from on-chain enumerability, for those cases see
 * {AccessControlEnumerable}.
 *
 * Roles are referred to by their `bytes32` identifier. These should be exposed
 * in the external API and be unique. The best way to achieve this is by
 * using `public constant` hash digests:
 *
 * ```
 * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
 * ```
 *
 * Roles can be used to represent a set of permissions. To restrict access to a
 * function call, use {hasRole}:
 *
 * ```
 * function foo() public {
 *     require(hasRole(MY_ROLE, msg.sender));
 *     ...
 * }
 * ```
 *
 * Roles can be granted and revoked dynamically via the {grantRole} and
 * {revokeRole} functions. Each role has an associated admin role, and only
 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
 *
 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
 * that only accounts with this role will be able to grant or revoke other
 * roles. More complex role relationships can be created by using
 * {_setRoleAdmin}.
 *
 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
 * grant and revoke this role. Extra precautions should be taken to secure
 * accounts that have been granted it.
 */
abstract contract AccessControl {
    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
     *
     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     *
     * _Available since v3.1._
     */
    event RoleAdminChanged(
        bytes32 indexed role,
        bytes32 indexed previousAdminRole,
        bytes32 indexed newAdminRole
    );

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call, an admin role
     * bearer except when using {AccessControl-_setupRole}.
     */
    event RoleGranted(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );

    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;

    /**
     * @dev Modifier that checks that an account has a specific role. Reverts
     * with a standardized message including the required role.
     *
     * The format of the revert reason is given by the following regular expression:
     *
     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
     *
     * _Available since v4.1._
     */
    modifier onlyRole(bytes32 role) {
        _checkRole(role, msg.sender);
        _;
    }

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role].members[account];
    }

    /**
     * @dev Revert with a standard message if `account` is missing `role`.
     *
     * The format of the revert reason is given by the following regular expression:
     *
     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
     */
    function _checkRole(bytes32 role, address account) internal view {
        if (!hasRole(role, account)) {
            revert(
                string(
                    abi.encodePacked(
                        "AccessControl: account ",
                        Strings.toHexString(uint160(account), 20),
                        " is missing role ",
                        Strings.toHexString(uint256(role), 32)
                    )
                )
            );
        }
    }

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roles[role].adminRole;
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(
        bytes32 role,
        address account
    ) external onlyRole(getRoleAdmin(role)) {
        _grantRole(role, account);
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(
        bytes32 role,
        address account
    ) external onlyRole(getRoleAdmin(role)) {
        _revokeRole(role, account);
    }

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been revoked `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) external {
        require(
            account == msg.sender,
            "AccessControl: can only renounce roles for self"
        );

        _revokeRole(role, account);
    }

    /**
     * @dev Sets `adminRole` as ``role``'s admin role.
     *
     * Emits a {RoleAdminChanged} event.
     */
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {
        bytes32 previousAdminRole = getRoleAdmin(role);
        _roles[role].adminRole = adminRole;
        emit RoleAdminChanged(role, previousAdminRole, adminRole);
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * Internal function without access restriction.
     */
    function _grantRole(bytes32 role, address account) internal {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, msg.sender);
        }
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * Internal function without access restriction.
     */
    function _revokeRole(bytes32 role, address account) internal {
        if (hasRole(role, account)) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, msg.sender);
        }
    }
}