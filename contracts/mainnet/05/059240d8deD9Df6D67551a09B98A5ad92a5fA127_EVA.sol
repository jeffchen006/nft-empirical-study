/*                                                                                                                                                                                        
                                                                . .......... ..                                                              
                                                         .........  .   ..   ..............                                                  
                                                  ............   ............:..     ...........                                             
                                             ..........  ..:~~7J5PGG5B#BBB#B#BBG5J?!^:.    ............                                      
                                         ..........  .:!?5B&&@@@@@@@@&&@@@@@@@@@@@@@@&#GJ~:.  .....::::^.                                    
    ............. ..     . .  ........   ......  .^75B#&&&&&&&&@@@&&#&@@@@@@@@@@@@@@@@@@@@&#Y!:........^..   .. .. .. ...   .... .. .. ....  
                                   ............~YG#&&&#&&&&&&&@@@@@&#@@@@@@@@@@@@@@@@@@&&@@@@@&P!:............    ..                         
     .......   . .     . ......  ...........:?G#####&#####&&&&&@@@&&@@@@@@@@@@@@@@@@@@@&&&&&&&&@&&5~............  ..  .  . ....... .. .. ..  
     . .     .    . .. .      ............^JG##BBBB########&&&&&&@&&&&@@@@@@@@@@@@@@@@@@@@@&&&&&&&&&G~. ..........    . . ...    . .  . ..   
     . .     .  . . .. .   .............^YB#BBBBBBBBBBBBB###&&&&&&##&@@@@@@@@@@@@@@@@@@@@@@@@@&&&&&&&&G!...........   . .                    
                          .....:...^~^~?B#BBGBBBBBBBBBBBB###&&&&&&##&&@@@@@@@@@@@@@@@@@@@@@@@@@@@&&###&&5:...::..  ..                        
      .:::::::.    .::::::::....:7?!~!P#BGGGGGGGGGGGBBBBB##&&&&&&&##&&@@@&&&&&&@@@@@@@@@@@@@@@@@@@&&&&##&#?....... .....::::::.   .::::::.   
      :......~.    ^^......~^..7J:.~~5BGGGBBGPPGGGGBBBB####&&&&&&&&#&&#BB##&&&&&&&@@@@@@@@@@@@@@@@@@&&&##&&5...::::::^.......:~.  ......^~   
            .~.    ^^    .^:...5::!~7GPGGBBGPPPPGGBBBBB###&&&&&@&&&#BGG#&&&#####&&@@@@@@@@@@@@@@@@@@@@&&###&G?7!77^~~:   ..  .~.        :~   
      .^::::::.    ^^   :^. .:!57:^~Y5PPPGGPPGGPGGBBB#####&&&&&&&&#BGG##BGBBBB##B##&&@@@@@@@@@@@@@@@@@@&&&####J:.^!.:..^^::::::.  ^^::::::   
      ~:           ^^ .^:  .:7~:J!^5P555PPGPPGGGGGB###&&&&@@@@@&&##BGBBB###&&&&&&&&&&&&@@@@@@@@@@@@@@@@@&&&&###!.:!.:..~.         ~.         
      ::::::::.  ::^^^~^::^^:7~:.~5BG55Y5PGBGGBBBB###&&&&&@@@@&&&##BGGBBGGGGGB##&&&&&&&@@@@@@@@@@@@@@@@@&&&&&##G:~:..^!~:::   ::. :^::::::.  
          ..     ...::~~^^!^~7!7~~GBGPP55PPPGBBB###&&&&&&&##BBB###GG5Y5JYYJJYYY5PG#&@&&&@@@@@@@@@@@@@@@@&&&&&###P^:^~:...     ...   ......   
     ....... ......:......^.^...:?#GPP555555PGBBBB##&&#BPYJ?????JY55YJJ?7777!~~~!!!?P&@@&&@&@@@@@@@@@@@@@&&&&&###5^.......                   
     . ... . .    ........ ::....Y#G5555555PGGBB####GJ!~^~~!77???JJYYYYJJ??77!!!!~~^^[emailÂ protected]@@&@@&@@@@@@@@@@@&&&&#&###!:.....   .......  ......  
       .    .    ...:..... ::...^GBGYYYYY5PPGBB#&##P?~~!7?JJJJYYY555PPPPGBBBBG5Y?7!!~^^J&@@&@@@@@@@@@@@@&&&&&&####Y.:....   ......~:.~:....  
    .           ....^:. .. ::.:.~BGPP5PP5Y5PB##&#BGY!!7??JJJYYYY5555PPPGB##&###BPY?!!!!~7#&@@&@@@@@@@@@&&&&&&&#####!^^....  .....:^..~:..:.  
    .  ...............:....::...!#GPPP5555GGPG#BBB5!!77??JJJYY55555PPPGGBBB#BBBBBGPY7~~~~7#&&@&@@@&@@@@&&&&&&&##B##P^:..... ......^..^. .. . 
    .   ......~. :.. ...:..^....J#GP5YYY55Y5B####B?~777??JJJYYY5555PPPPGGGGGGGGGGPPP5?~~^^J&&&&@@@@@@&@@@&&&&&&##B#B!::...:.......~:       ..
    .     ...:^. ^:.... ..^:.:^^5BGPPPPPPPBBB#&&GP!!777???JJJYYY55555PPPPGGGGPPPPP5555?!~^^P&&&&@&@@@@&&@@&&&#&&#BBBJ^:^:.....:..::.    .....
    .     ....^. :~.......!:^^^^YBBGGGGGGGGGB&&5!5!!777????JJJJYYYY55555PPPPP55555555YY?~~^!#&&&&@&@@@@&&@@&&&#B###BG~:^:^^.               ..
    .  .......^. .:~^.....~..^~^!BBGPPGGGGBBB&5^^J?!7777????JJJJJYYYY5555555555555YYYYYY7~~:5&&&&&@&&@@@&&&&&&&##BB##7.................... ..
    .  ......... ....:^:.:!..~^~:?BGGBBGGGGB&P^^~!?77777??????JJJJJYYYYYYYYYYYYYYYYYYYYYY!~~~##&&&&&&&@@@&&&&&&&&#BB#B?^....   ^~.......^^ ..
       ....... .........:^!.~!~~^:JBGBBGPGB#P^^~~!!?J????????????JJJJJJJJJJJJJYYYYYYY5555Y7!~Y&#&&#&&&&&&&&&&##&&&#BB#GJ^..:.  ^^       :^...
      .^:...:. ^^...... ..~.7!~^^:.PB5JPGBBP7~~^^^^~~!??JJJJJJJ???????JJJJJJJJJYYY55555YYJ7!:^#&#&##&&&&&&&&&&######BBB5?~..:^.:^:......^^ ..
      .~. .... ^^....   .:!~7!~!??!!5~~PBBGY77~^::::::::..::^~!777???????????????!~~^:....^:::J&##&##&&&&&&&&&&##BBB#BB5J~7: .:......:.... ..
      .~. ...  ^:      ..:7!!!~7^!!7!~~5GBG?~??7!~~~!!!!~^:.....:^~!7???????!~^:.....:^~!77!!~~B&B#&##&&&&&&&#&&###BB#BPY~^7^. .   ....... ..
      .^:::::. :::::::...:7~!!~7:~7~7?7YBBP!^~~^:............::^^::^!7?JJJ?7~^:::::...::.:... .P#&B&&##&&#&&&##&&##BBB#G?J.^!~..      .... ..
         . ..    ..... ...!!7!~!!?^~~!7PGGY7:.... ...~!^~:7~!:.^^:::!?JYYYJ?^:~~::^^7~!~^!~.   ?##&G&&###&&&&&##&#BBBB#B55~..^~. .     ..:...
      .. . ..  . ..... ...~777!~!?^^:^7Y5G?7^:^^^:.:!7JY55Y5Y7~!Y7::!JYPGPY?~!YJ!7JYYYYYYJ7^:..~#G&&B&&###&&#&&##&#BBBB#B55!^..^      .......
      ..     ...  .    ...:777!!~~7^:~:!YPJ7!~~!!!!!^^~!777??JYYY?!!7J5GBG5J?JY55YJ?77?7!!~!!~^:GBP&##&&#BB#&#######BBGBBB5J!!:.:.........   
     ..:...... .... ......:~7777!^~!^...^5J?!~!!!7?J?????JJY555YJ????Y5GBG5YYYYY55P5YYJJJJ?J?~::5#PP&##&#BBB#&###BB#BBGBBBJ77~~^..::::::^^   
     ... . ...      .    ..:~??77!^^!~:^^~YJ7~!!!7JJJJYYY55PPP5YJJ???Y5GBG5YJJY55PPPPP555YJ?7~^^5BG5G&B#&BBBBB&###BB#BGBBB?^77~^!^.     :^   
     ...... .. ......   . ...?J77!!::^7J!::J?!!!77JJJYYY555PPP5YJJ?7?J5PGP5JJJJY5PPPPP5555YJ?!^^PBGPY##G##BBGGB####GBBGGBBP:^!~~:^^^::::^:   
                          ..:~J?77!~^.:7!^.:J7!!!7?JJJYYY555P55YYJ7!7J55555J??JY55PPP555YYJJ7~^^Y#GP55#GG##BBGGB#B#BBBBGBBB^:7.:!^:. ...:^   
     .::::::   .:::::::::. .^:7~??7!~:..:!!^!J7!~!77??JJJYY55555YJ~~?Y5GGGPY??JY55PP55YYJJ??7~^^J#BPPYGG5G&BBBGGBBG#BBBBGBB!:7:..:::.   :~   
      ....^^    ....^^..^^ .::!~~J77!^::.....??!~!!77???JJYYY555Y777!?YPP5Y??Y?555555YYJJJ??7~~~5BBP555GJPP#BBGGPBBG#BGBGGBY!~:....:^:::^:   
          ^^       :^.  ^^...:~?:!?77!^^:....^J!~~!!77???JJJYY555^^^.:^~~^:.^^?PP555YYJJJ??7!!!7JBBP5YYGJ5YP#BGGGPBBG#BGGGG#?:!:..  ..       
          ^^      :~.   ^^ ...:7^:~77!~~:.....?7~~~!!!77??JJYYY557:::.....::^?GGP55YYJJ??77777!:YBBP5YY5YY57GBBGGP5BGGBGGBGBJ:^~. ...   .    
          ^^     .~.    ^^  ...^!^:!77!!^.:...^J!~~~~~!!7??JJYYYYYJ7777~~7YYPGGPP5YYJJ??77?77~^^YGBPYYJ5YJP7JGBGGG55BPBBGBGG5:.?..........   
       .  ^^    .~:     ^^ .....:~^^77!^~^^....7J!~~~~~!!77??JJJJJYJJJY55PPPP555YYJJ??77?7!~~~^~PGGPY5J5Y?P?75BPPBG5PG5BGGBP5!.~:.. .^.. .   
          ..    ..      .. ......:~~!77:.::^::..7J!~~~~~~!!777777!~^:::::::^~!7?77??7777!~~~~^~7PPG5J55YY?P?7JGGYPGGPG5GGGGPJ~:^..  ........ 
                       . .........:^~!?!:...:::..^??!~~~~~!!!!~^:..::^:::^~^::::^!777!!~~~~~!^ ~PPP5J55YJ?5J!JGG5PGPYP5PBGG57::~.     .....  
         .:::.  :::::::.............:^^77^....:.. .^7?!~~^~~~!!!!~~~!7777??7!!7777!!!~~~~~!^. .!PPP5J55Y?JY?!JPG55GGJ5Y5BGP5?:.^             
        .^..~. .~.   .~: .. ..........::~7!:.......  ~77!~~~~~~~~~~^:......:^~!!!!!~~^~!!~.  .:!5PPY5PYY?JY?!?PP5YGPJYY5GG5~~7~.. . ... ...  
      .^^. .~. .^:...:^. ..   ............~~~:.......^~::!!!~~~~~~^^:::::::^~!!!!~~~~!~:.:   :.!5PPY555J?JJ!77PP5YP5JYYPGGJ.^.~~:...:.... .. 
      :::::^^^..~.....^. ... .................^~~^^::^7:...^!!~~~~!7??JY5YYJ?7!~~~~~:....:  . ^~P5P55YY?JY7!7!5PYYPJJJYPPG~.:..!^...:....... 
           .~. .~.....~. ........  .......  ~Y!:.    .7:.....:~~~~!!7???J??77!!!~^.......:.  .:!555PYJ??J?!?77PP?YY?J?55PY..:..:::.........  
            ..  ........        ..     .. .?BP.      .7^:.......:^~~!!!!!!!!~~^..........:.  : 7Y555J??J!~?J~J5P?Y??JJ55P~... ...:^::....... 
     ...............................     .YBP557:    :7^::...........................::..:: . .J5555J?J!!7?~7Y55?J?J?J55Y........:::...      
       .  ...........  ... .  . .....    !BG5YJJY?~. :~:^^:::......................:^^^:.... .~Y55YY??!!?J~^YYP?J????75Y! ....... .......... 
     . .   . ... . ..  . . .  .  ..    .?GGPYJJ?77?J77^::^^^^:...................::^^^^^:..:~!!YYJYJ7!!77!~?55Y???77~JJ^::..  .    . .....   
       .  . ........ .............     :5GGGPP5YJ??7!7?77~^:::::................::^^^^^~!!!!~^?Y?YY7!!7~77?75Y7??7!^7?.:~^::...... .....:... 
       .......  .... .......... .   ...^55YYJY555YJJ?!~!!7?77~^^:.............:^~~~!777!!~~~~7?7Y57~!!~??7!Y5777~::!7:.!^................... 
                                 .~YPP5PP5YJ?7!!7??777!~~~~!!77777!!!~~~~~~!!77?77!!~~~~~~~!!~!5Y7~!77?!~!J577Y7.^!~::!:                     
      ... .. ...... ........ .  .5JY55Y?7?JJJ??7~~~~!!!!~~~~~~~~!!!!77777777!!~~~~~~~~~~~!!~^7Y?!~7?7^^~7?Y777JY~:...^. ....... ...  :. ...  
      ...... ..:... ........   .^7^:::^~~~!777!!!!!~~~~!!!!~~~~~!!!!!!!!!!~~~~~~~~~~~!!!~~^~JY77?7!~~!7??!?!~~~~7!..:.............  ...  .   
      ...................  .!JPP5Y5555J!^::::^~!!!!~!!!!!!!!!!!!!!!!7777!!!!!!!!!!777!!!~!?55J?!~!7J??7!~7!:~~!YGPY.  .... ................  
     ........ ........ .  .!?YP5J7!!!7?JJJ?!~::.::^^^^^^~~!!!!!!!~~~~~~!!!!77777777!!!~~!JY77!!7??7!~^~!7!^!????7~~~:.. :..:..:.:.......:.:  
                    .:!?5GG5!^^~7??7!^:^~!7?JJ??!~^::::::::^~~!!77777!!!!!~~!~~~~~~~~~!?Y?!!!~~!~^^^^~!7!!777!!~~!?YG5!~~:.    .  . .....    
                 .^!7???JY5PGPY?!!!7???7~:::^~!77????77!~^::::::^~~~~~~~~~~!!!!!!~~!7?J7~^~~~~^^^~~~~!7777!!~~!?Y5PP5Y?!~~!!:. ............  
             .:~JPGGGP5?~:..:~?Y55Y?777?JJ?7~^^^~~~!!777?????7!~~~~~~~~~~~~~~~~~~7JY?!~~!!~~^~~~~~~!!!?77!77JY55Y?~:..:~?5GGGPJ~:.      .    
          :!YPGBBGGGPGGGGPY?~:..:^!?YYJ????JYJJ?7!~~~~~~!!!!77??????JJJJJJJJJJJJJ?!!~~~~~~~~!!~~!!!!77777?JJ?7~:..:~?YPPPPPGGGBBBGY7^.       
       :?PBGPPPPPPPP5555555555YJ7^:::^!7???777?JJJJ??77!!!!!~~~~~~~~~~~~!!!!7JJ?7!!!!!!!!!!!!!!!!!!777!!!~^:::^!?Y5PP5555555PPPPPPGGBGY!.    
     ...^!J5P555555555555555555555YY?7!!!!!!!!!!!77??JJJJJJJJ???????7777777?YJ????JJJJJ??77!!!~!!!!!!!!!!7?JY555555555555555555555PP5J7^.    
           .:!JYYYYYJYYYYYYYYYYYYYYY555YYJJ??77!!!!!!!!777??JJJJJJJJJJJJJJYYJJJ????777!!!~~~~!!!!!!7?JYY555555YYYYYYYYYYYYYYYY55Y?~:.        
               .^!?YYYJJ???JJYYYYYYYYYYYYYYYYYYJJ?777!!!~~~~!!!!77????JJ?JY?77!!!!!!~~~~~!!!!!77?JYYYYYYYYYYYYYYYYYJJ???JJYYY?~:.            
                   .^!?JYJJ?????JJJJJJJJJJJJJJJJJJJJJJJ???77!!!!~~~!!!!!7?!!~~~~~~!!!!!77???JJJYYYJJJJJJJJJJJJJJ?????JJYJ?~:.                
                       .^!?JYJJ?????JJJJJJJJJJJJJJJJJJJJJJJJJJJJ????77!7?7!!77777????JJJJJJJJJJJJJJJJJJJJJJJ?????JJJJ7~:. ....               
                           .:~7JJJJ?????JJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJ?JJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJ?????JJJ?7~^:.......                 
                               .:~7?JJJ???????JJJ?J??????J????????JJJJJJJJJJJJJJJJJJJJJJ?JJJJJJJJJJ?????JJJJ?!~^::....                       
                                   ..^!??J????????????????????????J?JJJ?JJJ?J?JJJJJJ?????????????????JJJ7!^..  .                             
                                        .^~7????????????????7!!!!7!7!!!7!!!7!7?!!!7!7????????????J??7~:.                                     
                                            .:~!7?????7????7!~?7~!~7!!!7!!!?!??!!!7!7??????????7!^:.                                         
                                                ..^~7?????77????????????????????????77?????7~:.                                              
                                                     .:^!7????77777777??????777777????7!^:.                                                  
                                                         ..:~77???777777777777???77~:..                                                      
                                                              .:^!7???77777?77!^:.                                                           
                                                                  ..:~!77!~:..                                                               
                                                                       ..                                                                    
*/

// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";

contract EVA is Context, ERC20, Ownable {
    using SafeMath for uint256;

    IUniswapV2Router02 private uniswapV2Router02;

    mapping(address => uint256) private _cooldown;

    mapping(address => bool) private excludedFromFees;
    mapping(address => bool) private excludedFromMaxTx;
    mapping(address => bool) private blacklisted;

    bool public tradingOpen;
    bool private _swapping;
    bool public swapEnabled = false;
    bool public cooldownEnabled = false;
    bool public feesEnabled = true;
    bool public transferFeesEnabled = false;

    uint256 public maxBuyAmount;
    uint256 public maxSellAmount;
    uint256 public maxWalletAmount;

    uint256 public tradingOpenBlock = 0;
    uint256 private _blocksToBlacklist = 0;
    uint256 private _cooldownBlocks = 1;

    uint256 public constant FEE_DIVISOR = 10000;

    uint256 private _totalFees;
    uint256 private _treasuryFee;
    uint256 private _liquidityFee;

    uint256 public buyTreasuryFee = 300;
    uint256 private _previousBuyTreasuryFee = buyTreasuryFee;
    uint256 public buyLiquidityFee = 0;
    uint256 private _previousBuyLiquidityFee = buyLiquidityFee;

    uint256 public sellTreasuryFee = 300;
    uint256 private _previousSellTreasuryFee = sellTreasuryFee;
    uint256 public sellLiquidityFee = 0;
    uint256 private _previousSellLiquidityFee = sellLiquidityFee;

    uint256 public transferTreasuryFee = 300;
    uint256 private _previousTransferTreasuryFee = transferTreasuryFee;
    uint256 public transferLiquidityFee = 0;
    uint256 private _previousTransferLiquidityFee = transferLiquidityFee;

    uint256 private _tokensForTreasury;
    uint256 private _tokensForLiquidity;
    uint256 private _swapTokensAtAmount;

    address payable private _treasuryWallet;

    address private _uniswapV2Pair;
    address private constant DEAD = 0x000000000000000000000000000000000000dEaD;
    address private constant ZERO = 0x0000000000000000000000000000000000000000;

    enum TransactionType {
        BUY,
        SELL,
        TRANSFER
    }

    event OpenTrading(uint256 tradingOpenBlock, uint256 _blocksToBlacklist);
    event SetMaxBuyAmount(uint256 newMaxBuyAmount);
    event SetMaxSellAmount(uint256 newMaxSellAmount);
    event SetMaxWalletAmount(uint256 newMaxWalletAmount);
    event SetSwapTokensAtAmount(uint256 newSwapTokensAtAmount);
    event SetBuyFee(
        uint256 oldBuyTreasuryFee,
        uint256 oldBuyLiquidityFee,
        uint256 newBuyTreasuryFee,
        uint256 newBuyLiquidityFee
    );
    event SetSellFee(
        uint256 oldSellTreasuryFee,
        uint256 oldSellLiquidityFee,
        uint256 newSellTreasuryFee,
        uint256 newSellLiquidityFee
    );
    event SetTransferFee(
        uint256 oldTransferTreasuryFee,
        uint256 oldTransferLiquidityFee,
        uint256 newTransferTreasuryFee,
        uint256 newTransferLiquidityFee
    );

    modifier lockTheSwap() {
        _swapping = true;
        _;
        _swapping = false;
    }

    constructor(address payable treasuryWallet)
        ERC20("Engagement Virtual Assistant", "EVA")
    {
        require(
            treasuryWallet != ZERO,
            "EVA:constructor:ZERO_ADDRESS:treasuryWallet address cannot be 0"
        );

        uint256 _tSupply = 1e9 ether;
        maxBuyAmount = _tSupply;
        maxSellAmount = _tSupply;
        maxWalletAmount = _tSupply;

        uniswapV2Router02 = IUniswapV2Router02(
            0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D
        );
        _approve(address(this), address(uniswapV2Router02), _tSupply);
        _uniswapV2Pair = IUniswapV2Factory(uniswapV2Router02.factory())
            .createPair(address(this), uniswapV2Router02.WETH());
        IERC20(_uniswapV2Pair).approve(
            address(uniswapV2Router02),
            type(uint256).max
        );

        _treasuryWallet = treasuryWallet;

        excludedFromFees[owner()] = true;
        excludedFromFees[address(this)] = true;
        excludedFromFees[DEAD] = true;
        excludedFromFees[_treasuryWallet] = true;

        excludedFromMaxTx[owner()] = true;
        excludedFromMaxTx[address(this)] = true;
        excludedFromMaxTx[DEAD] = true;
        excludedFromMaxTx[_treasuryWallet] = true;

        _mint(owner(), _tSupply);
    }

    receive() external payable {}

    fallback() external payable {}

    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        require(
            from != ZERO,
            "EVA:_transfer:FROM_ZERO:transfer from the zero address"
        );
        require(
            to != ZERO,
            "EVA:_transfer:TO_ZERO:transfer to the zero address"
        );
        require(
            amount > 0,
            "EVA:_transfer:ZERO_AMOUNT:transfer amount must be greater than zero"
        );

        bool takeFee = true;
        TransactionType txType = (from == _uniswapV2Pair)
            ? TransactionType.BUY
            : (to == _uniswapV2Pair)
            ? TransactionType.SELL
            : TransactionType.TRANSFER;
        if (
            from != owner() &&
            to != owner() &&
            to != ZERO &&
            to != DEAD &&
            !_swapping
        ) {
            require(
                !blacklisted[from] && !blacklisted[to],
                "EVA:_transfer:BLACKLIST:blacklisted"
            );

            if (!tradingOpen)
                require(
                    excludedFromFees[from] || excludedFromFees[to],
                    "EVA:_transfer:TRADING_OFF:trading is not allowed yet"
                );

            if (cooldownEnabled) {
                if (
                    to != address(uniswapV2Router02) &&
                    to != address(_uniswapV2Pair)
                ) {
                    require(
                        _cooldown[tx.origin] < block.number - _cooldownBlocks &&
                            _cooldown[to] < block.number - _cooldownBlocks,
                        "EVA:_transfer:COOLDOWN:transfer delay enabled. Try again later."
                    );
                    _cooldown[tx.origin] = block.number;
                    _cooldown[to] = block.number;
                }
            }

            if (
                txType == TransactionType.BUY &&
                to != address(uniswapV2Router02) &&
                !excludedFromMaxTx[to]
            ) {
                require(
                    amount <= maxBuyAmount,
                    "EVA:_transfer:MAX_BUY:transfer amount exceeds the maxBuyAmount"
                );
                require(
                    balanceOf(to) + amount <= maxWalletAmount,
                    "EVA:_transfer:MAX_WALLET:transfer amount exceeds the maxWalletAmount"
                );
            }

            if (
                txType == TransactionType.SELL &&
                from != address(uniswapV2Router02) &&
                !excludedFromMaxTx[from]
            ) {
                require(
                    amount <= maxSellAmount,
                    "EVA:_transfer:MAX_SELL:transfer amount exceeds the maxSellAmount."
                );
            }
        }

        if (
            excludedFromFees[from] ||
            excludedFromFees[to] ||
            !feesEnabled ||
            (!transferFeesEnabled && txType == TransactionType.TRANSFER)
        ) takeFee = false;

        uint256 contractBalance = balanceOf(address(this));
        bool canSwap = (contractBalance > _swapTokensAtAmount) &&
            (txType == TransactionType.SELL);

        if (
            canSwap &&
            swapEnabled &&
            !_swapping &&
            !excludedFromFees[from] &&
            !excludedFromFees[to]
        ) {
            _swapBack(contractBalance);
        }

        _tokenTransfer(from, to, amount, takeFee, txType);
    }

    function _swapBack(uint256 contractBalance) internal lockTheSwap {
        uint256 totalTokensToSwap = _tokensForTreasury.add(_tokensForLiquidity);
        bool success;

        if (contractBalance == 0 || totalTokensToSwap == 0) return;

        if (contractBalance > _swapTokensAtAmount.mul(5))
            contractBalance = _swapTokensAtAmount.mul(5);

        uint256 liquidityTokens = contractBalance
            .mul(_tokensForLiquidity)
            .div(totalTokensToSwap)
            .div(2);
        uint256 tokensForSwap = contractBalance.sub(liquidityTokens);

        uint256 currentWeiBalance = address(this).balance;

        _swapExactTokensForETHSupportingFeeOnTransferTokens(tokensForSwap);

        uint256 weiEarned = address(this).balance.sub(currentWeiBalance);
        uint256 ethForTreasury = weiEarned.mul(_tokensForTreasury).div(
            totalTokensToSwap
        );
        uint256 ethForLiquidity = weiEarned.sub(ethForTreasury);

        _tokensForTreasury = 0;
        _tokensForLiquidity = 0;

        if (liquidityTokens > 0 && ethForLiquidity > 0)
            _addLiquidityETH(liquidityTokens, ethForLiquidity);

        (success, ) = address(_treasuryWallet).call{
            value: address(this).balance
        }("");
    }

    function _swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 tokenAmount
    ) internal {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapV2Router02.WETH();
        _approve(address(this), address(uniswapV2Router02), tokenAmount);
        uniswapV2Router02.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function _addLiquidityETH(uint256 tokenAmount, uint256 ethAmount) internal {
        _approve(address(this), address(uniswapV2Router02), tokenAmount);
        uniswapV2Router02.addLiquidityETH{value: ethAmount}(
            address(this),
            tokenAmount,
            0,
            0,
            _treasuryWallet,
            block.timestamp
        );
    }

    function isBlacklisted(address wallet) external view returns (bool) {
        return blacklisted[wallet];
    }

    function openTrading(uint256 blocks) public onlyOwner {
        require(
            !tradingOpen,
            "EVA:openTrading:TRADING_OPEN:trading is already open"
        );
        require(
            blocks <= 10,
            "EVA:openTrading:INVALID_BLOCKS:invalid blocks count"
        );
        maxBuyAmount = totalSupply().mul(1).div(100);
        maxSellAmount = totalSupply().mul(1).div(100);
        maxWalletAmount = totalSupply().mul(1).div(100);
        _swapTokensAtAmount = totalSupply().mul(5).div(10000);
        buyTreasuryFee = 2500;
        sellTreasuryFee = 2500;
        transferTreasuryFee = 2500;
        swapEnabled = true;
        cooldownEnabled = true;
        tradingOpen = true;
        tradingOpenBlock = block.number;
        _blocksToBlacklist = blocks;
        emit OpenTrading(tradingOpenBlock, _blocksToBlacklist);
    }

    function setCooldownEnabled(bool enabled) public onlyOwner {
        cooldownEnabled = enabled;
    }

    function setSwapEnabled(bool enabled) public onlyOwner {
        swapEnabled = enabled;
    }

    function setFeesEnabled(bool enabled) public onlyOwner {
        feesEnabled = enabled;
    }

    function setTransferFeesEnabled(bool enabled) public onlyOwner {
        transferFeesEnabled = enabled;
    }

    function setMaxBuyAmount(uint256 _maxBuyAmount) public onlyOwner {
        require(
            _maxBuyAmount >= (totalSupply().mul(1).div(1000)),
            "EVA:setMaxBuyAmount:MAX_BUY_THRESHOLD:max buy amount cannot be lower than 0.1% total supply"
        );
        maxBuyAmount = _maxBuyAmount;
        emit SetMaxBuyAmount(maxBuyAmount);
    }

    function setMaxSellAmount(uint256 _maxSellAmount) public onlyOwner {
        require(
            _maxSellAmount >= (totalSupply().mul(1).div(1000)),
            "EVA:setMaxSellAmount:MAX_SELL_THRESHOLD:max sell amount cannot be lower than 0.1% total supply"
        );
        maxSellAmount = _maxSellAmount;
        emit SetMaxSellAmount(maxSellAmount);
    }

    function setMaxWalletAmount(uint256 _maxWalletAmount) public onlyOwner {
        require(
            _maxWalletAmount >= (totalSupply().mul(1).div(1000)),
            "EVA:setMaxWalletAmount:MAX_WALLET_THRESHOLD:max wallet amount cannot be lower than 0.1% total supply"
        );
        maxWalletAmount = _maxWalletAmount;
        emit SetMaxWalletAmount(maxWalletAmount);
    }

    function setSwapTokensAtAmount(uint256 swapTokensAtAmount)
        public
        onlyOwner
    {
        require(
            swapTokensAtAmount >= (totalSupply().mul(1).div(100000)),
            "EVA:setSwapTokensAtAmount:MAX_SWAP_LOWER_THRESHOLD:swap amount cannot be lower than 0.001% total supply"
        );
        require(
            swapTokensAtAmount <= (totalSupply().mul(5).div(1000)),
            "EVA:setSwapTokensAtAmount:MAX_SWAP_HIGHER_THRESHOLD:swap amount cannot be higher than 0.5% total supply"
        );
        _swapTokensAtAmount = swapTokensAtAmount;
        emit SetSwapTokensAtAmount(_swapTokensAtAmount);
    }

    function setTreasuryWallet(address treasuryWallet) public onlyOwner {
        require(
            treasuryWallet != ZERO,
            "EVA:setTreasuryWallet:ZERO_ADDRESS:_treasuryWallet address cannot be 0"
        );
        excludedFromFees[_treasuryWallet] = false;
        excludedFromMaxTx[_treasuryWallet] = false;
        _treasuryWallet = payable(treasuryWallet);
        excludedFromFees[_treasuryWallet] = true;
        excludedFromMaxTx[_treasuryWallet] = true;
    }

    function excludeFromFees(address[] memory accounts, bool isEx)
        public
        onlyOwner
    {
        for (uint256 i = 0; i < accounts.length; i++)
            excludedFromFees[accounts[i]] = isEx;
    }

    function excludeFromMaxTx(address[] memory accounts, bool isEx)
        public
        onlyOwner
    {
        for (uint256 i = 0; i < accounts.length; i++)
            excludedFromMaxTx[accounts[i]] = isEx;
    }

    function blacklist(address[] memory accounts, bool isBL) public onlyOwner {
        for (uint256 i = 0; i < accounts.length; i++) {
            if (
                (accounts[i] != _uniswapV2Pair) &&
                (accounts[i] != address(uniswapV2Router02)) &&
                (accounts[i] != address(this))
            ) blacklisted[accounts[i]] = isBL;
        }
    }

    function setBuyFee(uint256 _buyTreasuryFee, uint256 _buyLiquidityFee)
        public
        onlyOwner
    {
        require(
            _buyTreasuryFee.add(_buyLiquidityFee) <= 1250,
            "EVA:setBuyFee:MAX_BUY_THRESHOLD:must keep buy taxes below 12.5%"
        );

        uint256 previousBuyTreasuryFee = buyTreasuryFee;
        uint256 previousBuyLiquidityFee = buyLiquidityFee;

        buyTreasuryFee = _buyTreasuryFee;
        buyLiquidityFee = _buyLiquidityFee;

        emit SetBuyFee(
            previousBuyTreasuryFee,
            previousBuyLiquidityFee,
            buyTreasuryFee,
            buyLiquidityFee
        );
    }

    function setSellFee(uint256 _sellTreasuryFee, uint256 _sellLiquidityFee)
        public
        onlyOwner
    {
        require(
            _sellTreasuryFee.add(_sellLiquidityFee) <= 1250,
            "EVA:setSellFee:MAX_SELL_THRESHOLD:must keep sell taxes below 12.5%"
        );
        uint256 previousSellTreasuryFee = sellTreasuryFee;
        uint256 previousSellLiquidityFee = sellLiquidityFee;

        sellTreasuryFee = _sellTreasuryFee;
        sellLiquidityFee = _sellLiquidityFee;

        emit SetSellFee(
            previousSellTreasuryFee,
            previousSellLiquidityFee,
            sellTreasuryFee,
            sellLiquidityFee
        );
    }

    function setTransferFee(
        uint256 _transferTreasuryFee,
        uint256 _transferLiquidityFee
    ) public onlyOwner {
        require(
            _transferTreasuryFee.add(_transferLiquidityFee) <= 1250,
            "EVA:setTransferFee:MAX_TRANSFER_THRESHOLD:must keep transfer taxes below 12.5%"
        );
        uint256 previousTransferTreasuryFee = transferTreasuryFee;
        uint256 previousTransferLiquidityFee = transferLiquidityFee;

        transferTreasuryFee = _transferTreasuryFee;
        transferLiquidityFee = _transferLiquidityFee;

        emit SetTransferFee(
            previousTransferTreasuryFee,
            previousTransferLiquidityFee,
            transferTreasuryFee,
            transferLiquidityFee
        );
    }

    function setCooldownBlocks(uint256 blocks) public onlyOwner {
        require(
            blocks <= 10,
            "EVA:setCooldownBlocks:INVALID_BLOCKS:invalid blocks count"
        );
        _cooldownBlocks = blocks;
    }

    function _deactivateFees() internal {
        if (
            buyTreasuryFee == 0 &&
            buyLiquidityFee == 0 &&
            sellTreasuryFee == 0 &&
            sellLiquidityFee == 0 &&
            transferTreasuryFee == 0 &&
            transferLiquidityFee == 0
        ) return;

        _previousBuyTreasuryFee = buyTreasuryFee;
        _previousBuyLiquidityFee = buyLiquidityFee;
        _previousSellTreasuryFee = sellTreasuryFee;
        _previousSellLiquidityFee = sellLiquidityFee;
        _previousTransferTreasuryFee = transferTreasuryFee;
        _previousTransferLiquidityFee = transferLiquidityFee;

        buyTreasuryFee = 0;
        buyLiquidityFee = 0;
        sellTreasuryFee = 0;
        sellLiquidityFee = 0;
        transferTreasuryFee = 0;
        transferLiquidityFee = 0;
    }

    function _activateFees() internal {
        buyTreasuryFee = _previousBuyTreasuryFee;
        buyLiquidityFee = _previousBuyLiquidityFee;
        sellTreasuryFee = _previousSellTreasuryFee;
        sellLiquidityFee = _previousSellLiquidityFee;
        transferTreasuryFee = _previousTransferTreasuryFee;
        transferLiquidityFee = _previousTransferLiquidityFee;
    }

    function _tokenTransfer(
        address sender,
        address recipient,
        uint256 amount,
        bool takeFee,
        TransactionType txType
    ) internal {
        if (!takeFee) _deactivateFees();
        else amount = _collectFees(sender, amount, txType);

        super._transfer(sender, recipient, amount);

        if (!takeFee) _activateFees();
    }

    function _collectFees(
        address sender,
        uint256 amount,
        TransactionType txType
    ) internal returns (uint256) {
        if (tradingOpenBlock + _blocksToBlacklist >= block.number) _setBot();
        else if (txType == TransactionType.SELL) _setSell();
        else if (txType == TransactionType.BUY) _setBuy();
        else if (txType == TransactionType.TRANSFER) _setTransfer();
        else
            revert(
                "EVA:_collectFees:INVALID_TRANSACTION_TYPE:invalid transaction type"
            );

        uint256 fees;
        if (_totalFees > 0) {
            fees = amount.mul(_totalFees).div(FEE_DIVISOR);
            _tokensForTreasury += (fees * _treasuryFee) / _totalFees;
            _tokensForLiquidity += (fees * _liquidityFee) / _totalFees;
        }

        if (fees > 0) super._transfer(sender, address(this), fees);

        return amount -= fees;
    }

    function _setBot() internal {
        _treasuryFee = 5551;
        _liquidityFee = 5551;
        _totalFees = _treasuryFee.add(_liquidityFee);
    }

    function _setSell() internal {
        _treasuryFee = sellTreasuryFee;
        _liquidityFee = sellLiquidityFee;
        _totalFees = _treasuryFee.add(_liquidityFee);
    }

    function _setBuy() internal {
        _treasuryFee = buyTreasuryFee;
        _liquidityFee = buyLiquidityFee;
        _totalFees = _treasuryFee.add(_liquidityFee);
    }

    function _setTransfer() internal {
        _treasuryFee = transferTreasuryFee;
        _liquidityFee = transferLiquidityFee;
        _totalFees = _treasuryFee.add(_liquidityFee);
    }

    function unclog() public onlyOwner {
        uint256 contractBalance = balanceOf(address(this));
        _swapExactTokensForETHSupportingFeeOnTransferTokens(contractBalance);
        bool success;
        (success, ) = address(_treasuryWallet).call{
            value: address(this).balance
        }("");
    }

    function withdrawStuckTokens(address tkn) public {
        require((_msgSender() == _treasuryWallet) || (_msgSender() == owner()));
        if (tkn == address(0)) {
            bool success;
            (success, ) = address(_treasuryWallet).call{
                value: address(this).balance
            }("");
        } else {
            require(
                tkn != address(this),
                "EVA:withdrawStuckTokens:INVALID_TOKEN:cannot withdraw own token"
            );
            require(
                IERC20(tkn).balanceOf(address(this)) > 0,
                "EVA:withdrawStuckTokens:INVALID_TOKEN_AMOUNT:no tokens"
            );
            uint256 amount = IERC20(tkn).balanceOf(address(this));
            IERC20(tkn).transfer(_treasuryWallet, amount);
        }
    }

    function normalizeFees() public onlyOwner {
        buyTreasuryFee = 300;
        sellTreasuryFee = 300;
        transferTreasuryFee = 300;
    }

    function normalizeLimits() public onlyOwner {
        maxBuyAmount = totalSupply();
        maxSellAmount = totalSupply();
        maxWalletAmount = totalSupply();
        cooldownEnabled = false;
    }
}

pragma solidity >=0.6.2;

import './IUniswapV2Router01.sol';

interface IUniswapV2Router02 is IUniswapV2Router01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}

pragma solidity >=0.5.0;

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)

pragma solidity ^0.8.0;

// CAUTION
// This version of SafeMath should only be used with Solidity 0.8 or later,
// because it relies on the compiler's built in overflow checks.

/**
 * @dev Wrappers over Solidity's arithmetic operations.
 *
 * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler
 * now has built in overflow checking.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
            // benefit is lost if 'b' is also tested.
            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the division of two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }

    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator.
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {trySub}.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b <= a, errorMessage);
            return a - b;
        }
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a / b;
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting with custom message when dividing by zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryMod}.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a % b;
        }
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)

pragma solidity ^0.8.0;

import "./IERC20.sol";
import "./extensions/IERC20Metadata.sol";
import "../../utils/Context.sol";

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin Contracts guidelines: functions revert
 * instead returning `false` on failure. This behavior is nonetheless
 * conventional and does not conflict with the expectations of ERC20
 * applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20, IERC20Metadata {
    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;

    /**
     * @dev Sets the values for {name} and {symbol}.
     *
     * The default value of {decimals} is 18. To select a different value for
     * {decimals} you should overload it.
     *
     * All two of these values are immutable: they can only be set once during
     * construction.
     */
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5.05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless this function is
     * overridden;
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view virtual override returns (uint8) {
        return 18;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address to, uint256 amount) public virtual override returns (bool) {
        address owner = _msgSender();
        _transfer(owner, to, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
     * `transferFrom`. This is semantically equivalent to an infinite approval.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * NOTE: Does not update the allowance if the current allowance
     * is the maximum `uint256`.
     *
     * Requirements:
     *
     * - `from` and `to` cannot be the zero address.
     * - `from` must have a balance of at least `amount`.
     * - the caller must have allowance for ``from``'s tokens of at least
     * `amount`.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual override returns (bool) {
        address spender = _msgSender();
        _spendAllowance(from, spender, amount);
        _transfer(from, to, amount);
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, allowance(owner, spender) + addedValue);
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        address owner = _msgSender();
        uint256 currentAllowance = allowance(owner, spender);
        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
        unchecked {
            _approve(owner, spender, currentAllowance - subtractedValue);
        }

        return true;
    }

    /**
     * @dev Moves `amount` of tokens from `from` to `to`.
     *
     * This internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `from` must have a balance of at least `amount`.
     */
    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(from, to, amount);

        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
        unchecked {
            _balances[from] = fromBalance - amount;
            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by
            // decrementing then incrementing.
            _balances[to] += amount;
        }

        emit Transfer(from, to, amount);

        _afterTokenTransfer(from, to, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply += amount;
        unchecked {
            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
            _balances[account] += amount;
        }
        emit Transfer(address(0), account, amount);

        _afterTokenTransfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
        unchecked {
            _balances[account] = accountBalance - amount;
            // Overflow not possible: amount <= accountBalance <= totalSupply.
            _totalSupply -= amount;
        }

        emit Transfer(account, address(0), amount);

        _afterTokenTransfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
     *
     * Does not update the allowance amount in case of infinite allowance.
     * Revert if not enough allowance is available.
     *
     * Might emit an {Approval} event.
     */
    function _spendAllowance(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance != type(uint256).max) {
            require(currentAllowance >= amount, "ERC20: insufficient allowance");
            unchecked {
                _approve(owner, spender, currentAllowance - amount);
            }
        }
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}

    /**
     * @dev Hook that is called after any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * has been transferred to `to`.
     * - when `from` is zero, `amount` tokens have been minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)

pragma solidity ^0.8.0;

import "../utils/Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

pragma solidity >=0.6.2;

interface IUniswapV2Router01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)

pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 *
 * _Available since v4.1._
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}