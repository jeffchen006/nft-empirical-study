// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

library Utils {
    struct PowerOfTwo {
        uint index;
        uint value;
    }

    function getPowerOfTwo(uint number) public pure returns(PowerOfTwo memory) {
        if (number < 16000000000000000000) return PowerOfTwo({index: 1000000000000000000, value: 8000000000000000000});
        if (number < 32000000000000000000) return PowerOfTwo({index: 2000000000000000000, value: 16000000000000000000});
        if (number < 64000000000000000000) return PowerOfTwo({index: 3000000000000000000, value: 32000000000000000000});
        if (number < 128000000000000000000) return PowerOfTwo({index: 4000000000000000000, value: 64000000000000000000});
        if (number < 256000000000000000000) return PowerOfTwo({index: 5000000000000000000, value: 128000000000000000000});
        if (number < 512000000000000000000) return PowerOfTwo({index: 6000000000000000000, value: 256000000000000000000});
        if (number < 1024000000000000000000) return PowerOfTwo({index: 7000000000000000000, value: 512000000000000000000});
        if (number < 2048000000000000000000) return PowerOfTwo({index: 8000000000000000000, value: 1024000000000000000000});
        if (number < 4096000000000000000000) return PowerOfTwo({index: 9000000000000000000, value: 2048000000000000000000});
        if (number < 8192000000000000000000) return PowerOfTwo({index: 10000000000000000000, value: 4096000000000000000000});
        if (number < 16384000000000000000000) return PowerOfTwo({index: 11000000000000000000, value: 8192000000000000000000});
        if (number < 32768000000000000000000) return PowerOfTwo({index: 12000000000000000000, value: 16384000000000000000000});
        if (number < 65536000000000000000000) return PowerOfTwo({index: 13000000000000000000, value: 32768000000000000000000});
        if (number < 131072000000000000000000) return PowerOfTwo({index: 14000000000000000000, value: 65536000000000000000000});
        if (number < 262144000000000000000000) return PowerOfTwo({index: 15000000000000000000, value: 131072000000000000000000});
        if (number < 524288000000000000000000) return PowerOfTwo({index: 16000000000000000000, value: 262144000000000000000000});
        if (number < 1048576000000000000000000) return PowerOfTwo({index: 17000000000000000000, value: 524288000000000000000000});
        if (number < 2097152000000000000000000) return PowerOfTwo({index: 18000000000000000000, value: 1048576000000000000000000});
        if (number < 4194304000000000000000000) return PowerOfTwo({index: 19000000000000000000, value: 2097152000000000000000000});
        if (number < 8388608000000000000000000) return PowerOfTwo({index: 20000000000000000000, value: 4194304000000000000000000});
        if (number < 16777216000000000000000000) return PowerOfTwo({index: 21000000000000000000, value: 8388608000000000000000000});
        if (number < 33554432000000000000000000) return PowerOfTwo({index: 22000000000000000000, value: 16777216000000000000000000});
        if (number < 67108864000000000000000000) return PowerOfTwo({index: 23000000000000000000, value: 33554432000000000000000000});
        if (number < 134217728000000000000000000) return PowerOfTwo({index: 24000000000000000000, value: 67108864000000000000000000});
        if (number < 268435456000000000000000000) return PowerOfTwo({index: 25000000000000000000, value: 134217728000000000000000000});
        if (number < 536870912000000000000000000) return PowerOfTwo({index: 26000000000000000000, value: 268435456000000000000000000});
        if (number < 1073741824000000000000000000) return PowerOfTwo({index: 27000000000000000000, value: 536870912000000000000000000});
        if (number < 2147483648000000000000000000) return PowerOfTwo({index: 28000000000000000000, value: 1073741824000000000000000000});
        if (number < 4294967296000000000000000000) return PowerOfTwo({index: 29000000000000000000, value: 2147483648000000000000000000});

        return PowerOfTwo({index: 30000000000000000000, value: 4294967296000000000000000000});
    }

    function bytesToUint(bytes memory _bytes, uint _start) internal pure returns (uint) {
        require(_bytes.length >= _start + 32, "OB");
        uint tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x20), _start))
        }

        return tempUint;
    }
}