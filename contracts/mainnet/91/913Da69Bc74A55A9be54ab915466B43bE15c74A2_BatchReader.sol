// SPDX-License-Identifier: MIT-BROUGKR
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @dev: @brougkr
 */
pragma solidity 0.8.17;
contract BatchReader 
{
    struct CitizenCity
    {
        string Name;
        address ContractAddress;
        uint StartingTokenID;
        uint EndingTokenID;
        bool Active;
    }
    struct User
    {
        uint[] _City1;
        uint[] _City2;
        uint[] _City3;
        uint[] _City4;
        uint[] _City5;
        uint[] _City6;
        uint[] _City7;
        uint[] _City8;
        uint[] _City9;
        uint[] _City10;
    }
    CitizenCity[] CitizenCities;
    mapping(address=>bool) Roles;
    event NewCity(string Name, address ContractAddress, uint StartingTokenID, uint EndingTokenID, bool Active);
    event ModifiedCity(string Name, address ContractAddress, uint StartingTokenID, uint EndingTokenID, bool Active);
    constructor()
    {
        Roles[msg.sender] = true; // deployer.brightmoments.eth
        Roles[0x18B7511938FBe2EE08ADf3d4A24edB00A5C9B783] = true; // phil.brightmoments.eth
        Roles[0xB96E81f80b3AEEf65CB6d0E280b15FD5DBE71937] = true; // brightmoments.eth
        CitizenCities.push(CitizenCity('CryptoGalacticans', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 0, 999, true));
        CitizenCities.push(CitizenCity('CryptoVenetians', 0xa7d8d9ef8D8Ce8992Df33D8b8CF4Aebabd5bD270, 95000000, 95000999, true));
        CitizenCities.push(CitizenCity('CryptoNewYorkers', 0xa7d8d9ef8D8Ce8992Df33D8b8CF4Aebabd5bD270, 189000000, 189000999, true));
        CitizenCities.push(CitizenCity('CryptoBerliners', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 3000000, 3000999, true));
        CitizenCities.push(CitizenCity('CryptoLondoners', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 4000000, 4000999, true));
        CitizenCities.push(CitizenCity('CryptoMexas', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 5000000, 5000999, true));
        CitizenCities.push(CitizenCity('City #7', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 6000000, 6000999, false));
        CitizenCities.push(CitizenCity('City #8', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 7000000, 7000999, false));
        CitizenCities.push(CitizenCity('City #9', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 8000000, 8000999, false));
        CitizenCities.push(CitizenCity('City #10', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 9000000, 9000999, false));
    }

    /*******************
     * ADMIN FUNCTIONS *
     ******************/
    
    /**
     * @dev Adds Citizen City
     */
    function CitizenCityAdd(
        string calldata Name,
        address ContractAddress, 
        uint StartingTokenID, 
        uint EndingTokenID,
        bool Active
    ) external onlyBRTAdmin {   
        CitizenCities.push(CitizenCity(Name, ContractAddress, StartingTokenID, EndingTokenID, Active));
        emit NewCity(Name, ContractAddress, StartingTokenID, EndingTokenID, Active);
    }

    /**
     * @dev Modifies Citizen City
     */
    function CitizenCityModify(
        uint CityNumber, 
        string calldata Name, 
        address ContractAddress, 
        uint StartingTokenID, 
        uint EndingTokenID,
        bool Active
    ) external onlyBRTAdmin {
        CitizenCities[CityNumber].Name = Name;
        CitizenCities[CityNumber].ContractAddress = ContractAddress;
        CitizenCities[CityNumber].StartingTokenID = StartingTokenID;
        CitizenCities[CityNumber].EndingTokenID = EndingTokenID;
        emit ModifiedCity(Name, ContractAddress, StartingTokenID, EndingTokenID, Active);
    }

    /**
     * @dev Flips Citizen City Active State
     */
    function CitizenCityFlipActiveState(uint CityNumber) external onlyBRTAdmin 
    {
        CitizenCities[CityNumber].Active = !CitizenCities[CityNumber].Active;
    }

    /******************
     * VIEW FUNCTIONS *
     *****************/

    /**
     * @dev Returns Citizens Owned By Wallet
     */
    function readWalletOwnedCitizensArray(address Wallet) public view returns(uint[][] memory)
    {
        uint[][] memory Owners = new uint[][](CitizenCities.length);
        for(uint x; x < CitizenCities.length; x++)
        {
            uint Range = CitizenCities[x].EndingTokenID - CitizenCities[x].StartingTokenID + 1;
            IERC721 NFT = IERC721(CitizenCities[x].ContractAddress);
            uint[] memory temp = new uint[](Range);
            uint NumOwnedTokens;
            for(uint TokenID = CitizenCities[x].StartingTokenID; TokenID <= CitizenCities[x].EndingTokenID; TokenID++)
            {
                try NFT.ownerOf(TokenID) 
                {
                    if(NFT.ownerOf(TokenID) == Wallet)
                    {
                        temp[NumOwnedTokens] = TokenID;
                        NumOwnedTokens++;   
                    }
                } catch { }
            }
            uint[] memory FormattedOwnedIDs = new uint[](NumOwnedTokens);
            uint index;
            for(uint z; z < NumOwnedTokens; z++)
            {
                if(temp[z] != 0 || (z == 0 && temp[z] == 0))
                {
                    FormattedOwnedIDs[index] = temp[z];
                    index++;
                }
            }
            Owners[x] = FormattedOwnedIDs;
        }
        return Owners;
    }

    /**
     * @dev Batch Returns If Wallet Owns Multiple TokenIDs Of Multiple NFTs
     */
    function readNFTsOwnedTokenIDs(
        address Wallet, 
        address[] calldata NFTAddresses, 
        uint Range
    ) public view returns (uint[][] memory) {
        uint[][] memory OwnedIDs = new uint[][](NFTAddresses.length);
        for(uint x; x < NFTAddresses.length; x++)
        {
            IERC721 NFT = IERC721(NFTAddresses[x]);
            uint[] memory temp = new uint[](Range);
            uint NumOwnedTokens;
            for(uint y; y <= Range; y++)
            {
                try NFT.ownerOf(y) 
                {
                    if(NFT.ownerOf(y) == Wallet)
                    {
                        temp[NumOwnedTokens] = y;
                        NumOwnedTokens++;   
                    }
                } catch { }
            }
            uint[] memory FormattedOwnedIDs = new uint[](NumOwnedTokens);
            uint index;
            for(uint z; z < NumOwnedTokens; z++)
            {
                if(temp[z] != 0 || (z == 0 && temp[z] == 0))
                {
                    FormattedOwnedIDs[index] = temp[z];
                    index++;
                }
            }
            OwnedIDs[x] = FormattedOwnedIDs;
        }
        return OwnedIDs;
    }

    /**
     * @dev Batch Returns Owners Of Collection
     */
    function readNFTOwners(
        address[] calldata NFTAddresses, 
        uint Range
    ) public view returns (address[][] memory) {
        address[][] memory Owners = new address[][](NFTAddresses.length);
        for(uint x; x < NFTAddresses.length; x++)
        {
            IERC721 NFT = IERC721(NFTAddresses[x]);
            address[] memory temp = new address[](Range);
            uint NumOwnedTokens;
            for(uint y; y <= Range; y++)
            {
                try NFT.ownerOf(y) 
                {
                    if(NFT.ownerOf(y) != address(0))
                    {
                        temp[NumOwnedTokens] = NFT.ownerOf(y);
                        NumOwnedTokens++;   
                    }
    
                } 
                catch 
                { 
                    temp[NumOwnedTokens] = address(0);
                    NumOwnedTokens++;
                }
            }
            address[] memory FormattedOwnedIDs = new address[](NumOwnedTokens);
            uint index;
            for(uint z; z < NumOwnedTokens; z++)
            {
                if(temp[z] != address(0))
                {
                    FormattedOwnedIDs[index] = temp[z];
                    index++;
                }
            }
            Owners[x] = FormattedOwnedIDs;
        }
        return Owners;
    }

    /**
     * @dev Batch Returns All Citizen Owners
     */
    function readCitizenOwners() public view returns (address[][] memory) {
        address[][] memory Owners = new address[][](CitizenCities.length);
        for(uint CityID; CityID < CitizenCities.length; CityID++)
        {
            uint Range = CitizenCities[CityID].EndingTokenID - CitizenCities[CityID].StartingTokenID + 1;
            IERC721 NFT = IERC721(CitizenCities[CityID].ContractAddress);
            address[] memory temp = new address[](Range);
            uint NumOwnedTokens;
            for(uint TokenID = CitizenCities[CityID].StartingTokenID; TokenID <= CitizenCities[CityID].EndingTokenID; TokenID++)
            {
                try NFT.ownerOf(TokenID) 
                {
                    if(NFT.ownerOf(TokenID) != address(0))
                    {
                        temp[NumOwnedTokens] = NFT.ownerOf(TokenID);
                        NumOwnedTokens++;   
                    }
                } 
                catch 
                { 
                    temp[NumOwnedTokens] = address(0);
                    NumOwnedTokens++;
                }
            }
            address[] memory FormattedOwnedIDs = new address[](NumOwnedTokens);
            uint index;
            for(uint z; z < NumOwnedTokens; z++)
            {
                FormattedOwnedIDs[index] = temp[z];
                index++;
            }
            Owners[CityID] = FormattedOwnedIDs;
        }
        return Owners;
    }

    /**
     * @dev Returns Citizens Owned By Wallet
     */
    function readWalletOwnedCitizens(address Wallet) public view returns(User memory)
    {
        uint[][] memory Owners = new uint[][](CitizenCities.length);
        for(uint x; x < CitizenCities.length; x++)
        {
            if(CitizenCities[x].Active)
            {
                uint Range = CitizenCities[x].EndingTokenID - CitizenCities[x].StartingTokenID + 1;
                IERC721 NFT = IERC721(CitizenCities[x].ContractAddress);
                uint[] memory temp = new uint[](Range);
                uint NumOwnedTokens;
                for(uint TokenID = CitizenCities[x].StartingTokenID; TokenID <= CitizenCities[x].EndingTokenID; TokenID++)
                {
                    try NFT.ownerOf(TokenID) 
                    {
                        if(NFT.ownerOf(TokenID) == Wallet)
                        {
                            temp[NumOwnedTokens] = TokenID;
                            NumOwnedTokens++;   
                        }
                    } catch { }
                }
                uint[] memory FormattedOwnedIDs = new uint[](NumOwnedTokens);
                uint index;
                for(uint z; z < NumOwnedTokens; z++)
                {
                    if(temp[z] != 0 || (z == 0 && temp[z] == 0))
                    {
                        FormattedOwnedIDs[index] = temp[z];
                        index++;
                    }
                }
                Owners[x] = FormattedOwnedIDs;
            }
            else { Owners[x] = new uint[](0); }
        }
        User memory _User = User(
            Owners[0],
            Owners[1],
            Owners[2],
            Owners[3],
            Owners[4],
            Owners[5],
            Owners[6],
            Owners[7],
            Owners[8],
            Owners[9]
        );
        return _User;
    }

    /**
     * @dev Batch Returns All Citizen Owners
     */
    function readCitizenOwnersByCity(uint[] calldata CityIndex) public view returns (address[][] memory) {
        address[][] memory Owners = new address[][](CitizenCities.length);
        for(uint CityID; CityID < CityIndex.length; CityID++)
        {
            uint Range = CitizenCities[CityIndex[CityID]].EndingTokenID - CitizenCities[CityIndex[CityID]].StartingTokenID + 1;
            IERC721 NFT = IERC721(CitizenCities[CityIndex[CityID]].ContractAddress);
            address[] memory temp = new address[](Range);
            uint NumOwnedTokens;
            for(
                uint TokenID = CitizenCities[CityIndex[CityID]].StartingTokenID; 
                TokenID <= CitizenCities[CityIndex[CityID]].EndingTokenID; 
                TokenID++
            )
            {
                try NFT.ownerOf(TokenID) 
                {
                    if(NFT.ownerOf(TokenID) != address(0))
                    {
                        temp[NumOwnedTokens] = NFT.ownerOf(TokenID);
                        NumOwnedTokens++;   
                    }
                } 
                catch 
                { 
                    temp[NumOwnedTokens] = address(0);
                    NumOwnedTokens++;
                }
            }
            address[] memory FormattedOwnedIDs = new address[](NumOwnedTokens);
            uint index;
            for(uint z; z < NumOwnedTokens; z++)
            {
                FormattedOwnedIDs[index] = temp[z];
                index++;
            }
            Owners[CityID] = FormattedOwnedIDs;
        }
        return Owners;
    }

    /**
     * @dev Returns Batch Metadata
     */
    function readBatchMetadata(
        address[] calldata ContractAddresses, 
        uint[][] calldata TokenIDs
    ) public view returns(string[][] memory) {
        string[][] memory Metadata = new string[][](TokenIDs.length);
        for(uint ProjectID; ProjectID < ContractAddresses.length; ProjectID++)
        {
            string[] memory ProjectMetadata = new string[](TokenIDs[ProjectID].length);
            for(uint TokenID; TokenID < TokenIDs[ProjectID].length; TokenID++)
            {
                ProjectMetadata[TokenID] = IERC721(ContractAddresses[ProjectID]).tokenURI(TokenIDs[ProjectID][TokenID]);
            }
            Metadata[ProjectID] = ProjectMetadata;
        }
        return Metadata;
    }

    /**
     * @dev Returns Batch Metadata Of Citizens Held By `Wallet`
     */
    function readBatchMetadataCitizens(
        address Wallet
    ) public view returns(string[][] memory) {
        string[][] memory Metadata = new string[][](CitizenCities.length);
        uint[][] memory TokenIDs = readWalletOwnedCitizensArray(Wallet);
        for(uint ProjectID; ProjectID < CitizenCities.length; ProjectID++)
        {
            string[] memory ProjectMetadata = new string[](TokenIDs[ProjectID].length);
            for(uint TokenID; TokenID < TokenIDs[ProjectID].length; TokenID++)
            {
                ProjectMetadata[TokenID] = IERC721(CitizenCities[ProjectID].ContractAddress).tokenURI(TokenIDs[ProjectID][TokenID]);
            }
            Metadata[ProjectID] = ProjectMetadata;
        }
        return Metadata;
    }

    /**
     * @dev Returns A Wallet's Owned Moments NFTs
     */
    function readWalletOwnedMoments(
        address Wallet,
        uint[] calldata ProjectIDs,
        uint Range
    ) public view returns(uint[][] memory) {
        uint[][] memory OwnedIDs = new uint[][](ProjectIDs.length);
        IERC721 Moments = IERC721(0x0A1BBD57033F57E7B6743621b79fCB9Eb2CE3676);
        for(uint x; x < ProjectIDs.length; x++)
        {
            uint[] memory temp = new uint[](Range);
            uint _TokenID = ProjectIDs[x] * 1000000;
            uint _Range = _TokenID + Range;
            uint NumOwnedTokens;
            for(_TokenID; _TokenID < _Range; _TokenID++)
            {
                try Moments.ownerOf(_TokenID) 
                {
                    if(Moments.ownerOf(_TokenID) == Wallet)
                    {
                        temp[NumOwnedTokens] = _TokenID;
                        NumOwnedTokens++;
                    }
                } catch { }
            }
            uint[] memory FormattedOwnedIDs = new uint[](NumOwnedTokens);
            for(uint z; z < NumOwnedTokens; z++) { FormattedOwnedIDs[z] = temp[z]; }
            OwnedIDs[x] = FormattedOwnedIDs;
        }
        return OwnedIDs;
    }

    /**
     * @dev BRT Admin Modifier
     */
    modifier onlyBRTAdmin
    {
        require(Roles[msg.sender]);
        _;
    }
}

interface IERC721
{
    function ownerOf(uint) external view returns (address);
    function tokenURI(uint) external view returns (string memory);
}