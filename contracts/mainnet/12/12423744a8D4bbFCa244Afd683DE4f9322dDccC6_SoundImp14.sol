// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

library SoundImp14 {

  string internal constant PART = "stop(),V.stop(),s.stop();let o=A+(1e3*Math.random()-1e3*Math.random()),a=q+(3*Math.random()-3*Math.random()),i=e+(5*Math.random()-5*Math.random());0==t&&0==playElectricLoop||playElectric(o,a,i)}),1e3*q)}async function applyFXWithPanningLoopFade(A,q,e,t,o,a,n=1,i=1,V=1){const g=await getImpulseBuffer(reverbData),s=q.createConvolver();s.buffer=g;const C=q.createDelay();t=Math.min(Math.max(t,0),1),C.delayTime.value=t;const E=q.createGain();E.gain.value=o;const c=q.createStereoPanner();c.pan.value=a;const B=q.createBufferSource();B.buffer=e,B.loop=!0;q.createGain().gain.value=o,B.connect(C),C.connect(E),E.connect(s).connect(c);const M=q.createGain();M.gain.value=n;const I=q.currentTime,r=e.duration,Q=I,l=Math.max(I,I+r-V);M.gain.setValueAtTime(0,Q),M.gain.linearRampToValueAtTime(n,Q+i),M.gain.setValueAtTime(n,l),M.gain.linearRampToValueAtTime(0,l+V),c.connect(M),M.connect(masterGain).connect(bandpassFilter).connect(q.destination),B.start(),B.onended=()=>{1==app.audio&&0==holdOnSoundEvents&&(B.disconnect(),C.disconnect(),E.disconnect(),c.disconnect(),M.disconnect(),playEchoFXFade(A,C.delayTime.value,E.gain.value,c.pan.value,n,i,V))}}async function playEchoFXFade(A=\"noidechofade\",q=.2,e=.3,t=0,o=.23,a=1,n=1,i=1){const V=generateBreakingFXSize(audioContext);return await applyFXWithPanningLoopFade(A,audioContext,V,q,e,t,o,a,n,i)}function altarEngage(){drum(\"kick\",.2)}function altarOpen(){doorsRev(\"open\",.4)}function altarSent(){doorsRev(\"close\",6)}function altarPop(){drum(\"hihat\",.2)}function altarSporadicDrop(){let A=2*Math.random(),q=60*Math.random();2*Math.random()>1?dropSound2(6+A,100,501,2+A,.1,.02):dropSound2(60+q,100,5,2,.1,.02)}async function makeChoir(A=5,q=3,e=260,t=.1){const o=await decodeImpulseDataIfNeeded(),a=audioContext.createConvolver();a.buffer=o;const n=audioContext.createDynamicsCompressor();n.threshold.value=-12,n.knee.value=10,n.ratio.value=6,n.attack.value=.1,n.release.value=.5;const i=audioContext.createGain(),V=[],g=[];for(let A=0;A<q;A++)V[A]=audioContext.createOscillator(),g[A]=audioContext.createGain(),V[A].connect(g[A]),g[A].connect(a),a.connect(n),n.connect(i),i.connect(masterGain).connect(bandpassFilter).connect(audioContext.destination);const s=Math.pow(2,1/12);for(let A=0;A<q;A++)V[A].frequency.value=e*Math.pow(s,A-q/2),V[A].type=\"sine\";V[0].frequency.value=e,V[1].frequency.value=e*Math.pow(s,4),V[2].frequency.value=e*Math.pow(s,7),i.gain.value=t;for(let A=0;A<q;A++)V[A].start(),g[A].gain.setValueAtTime(.01,audioContext.currentTime),g[A].gain.linearRampToValueAtTime(1,audioContext.currentTime+.5);for(let e=0;e<q;e++)V[e].stop(audioContext.currentTime+A),g[e].gain.setValueAtTime(1,audioContext.currentTime+A-1),g[e].gain.linearRampToValueAtTime(.01,audioContext.currentTime+A),V[e].onended=function(){1==app.audio&&0==holdOnSoundEvents&&(app.audioContexts=app.audioContexts.filter((A=>\"choir\"!=A.id)))}}let mediaRecorder,eventSounds=!0;function noseSniff(){doors(\"close\",.01+Math.floor(2*Math.random()))}function boilingWater(A=\"unknown\",q=.25,e=.1,t=1.5){(new Date).getTime();let o=2*audioContext.sampleRate,a=audioContext.createBuffer(1,o,audioContext.sampleRate),n=a.getChannelData(0);for(let A=0;A<o;A++){let t=Math.random()*q;n[A]=t-t*e}let i=audioContext.createBufferSource();i.buffer=a,i.loop=!0;let V=audioContext.createGain(),g=audioContext.createBiquadFilter();g.type=\"lowpass\",g.frequency.value=1e3,i.connect(V),V.connect(g),g.connect(masterGain).connect(bandpassFilter).connect(audioContext.destination),V.gain.setValueAtTime(0,audioContext.currentTime),V.gain.linearRampToValueAtTime(1,audioContext.currentTime+t),i.onended=function(){app.audio},i.start()}async function playWhiteNoise(A=10,q=1e3,e=!1){const t=audioContext.createScriptProcessor(4096,1,1),o=await getImpulseBuffer(reverbData),a=audioContext.createConvolver();a.buffer=o,t.onaudioprocess=function(A){const q=A.outputBuffer.getChannelData(0);for(let A=0;A<4096;A++)q[A]=.5*Math.random()-.5};const n=audioContext.createBiquadFilter();n.type=\"bandpass\",n.frequency.value=q,n.Q.value=1;const i=audioContext.createOscillator(),V=audioContext.createGain();i.type=\"sine\",i.frequency.value=5,V.gain.value=500,i.connect(V),V.connect(n.frequency),t.connect(n),n.connect(a).connect(masterGain).connect(bandpassFilter).connect(audioContext.destination),i.start(),t.connect(a).connect(masterGain).connect(bandpassFilter).connect(audioContext.destination),setTimeout((()=>{1==e&&(t.disconnect(a),t.onaudioprocess=null,i.stop())}),1e3*A)}function makeNoise(A=1,q=1,e=1,t=1){const o=audioContext.createBufferSource(),a=audioContext.createBuffer(1,audioContext.sampleRate*e,audioContext.sampleRate),n=a.getChannelData(0);for(let q=0;q<n.length;q++)n[q]=Math.random()*A-A;o.buffer=a;const i=audioContext.createGain();o.connect(i).connect(masterGain).connect(bandpassFilter).connect(audioContext.destination),i.gain.setValueAtTime(q,audioContext.currentTime),i.gain.exponentialRampToValueAtTime(.01,audioContext.currentTime+t),o.start()}function isSecure(){return\"https:\"===location.protocol||location.protocol.startsWith(\"blob:\")}function isGetUserMediaSupported(){return!(!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)}let recordedChunks=[];async function startRecording(A){try{new(window.AudioContext||window.webkitAudioContext);const q=await navigator.mediaDevices.getUserMedia({audio:!0});mediaRecorder=new MediaRecorder(q),mediaRecorder.addEventListener(\"dataavailable\",(A=>{A.data.size>0&&recordedChunks.push(A.data)})),mediaRecorder.start(),setTimeout((()=>{mediaRecorder.stop()}),A)}catch(A){}}function playRecording(){if(0===recordedChunks.length)return;const A=[...recordedChunks].reverse(),q=new Blob(A,{type:\"audio/ogg; codecs=opus\"}),e=URL.createObjectURL(q),t=new Audio(e);audio.playbackRate=-1,t.play()}function bufferToWav(A){const q=A.numberOfChannels,e=A.sampleRate,t=2===q?1:3,o=2*q,a=A.length,n=a*o,i=44+n,V=new ArrayBuffer(44),g=new DataView(V);g.setUint32(0,1380533830,!1),g.setUint32(4,i-8,!0),g.setUint32(8,1463899717,!1),g.setUint32(12,1718449184,!1),g.setUint32(16,16,!0),g.setUint16(20,t,!0),g.setUint16(22,q,!0),g.setUint32(24,e,!0),g.setUint32(28,e*o,!0),g.setUint16(32,o,!0),g.setUint16(34,16,!0),g.setUint32(36,1684108385,!1),g.setUint32(40,n,!0);const s=new Float32Array(a*q);for(let e=0;e<a;e++)for(let t=0;t<q;t++)s[e*q+t]=A.getChannelData(t)[e];const C=new Int16Array(i/2);for(let A=0;A<22;A++)C[A]=g.getInt16(2*A,!0);for(let A=0;A<a*q;A++)C[A+22]=32766*s[A];return C}async function playRSound(A=440,q=.5,e=1,t=5,o=.5,a=.1){await decodeImpulseDataIfNeeded();A=Math.max(20,Math.min(2e4,A)),q=Math.max(0,Math.min(1,q));for(let n=0;n<t;n++){const t=audioContext.createOscillator(),i=audioContext.createGain();audioContext.createConvolver().buffer=reverbBuffer,t.frequency.value=A,t.connect(i),i.connect(masterGain).connect(bandpassFilter).connect(audioContext.destination);const V=audioContext.currentTime+n*(e+o+Math.random()*a),g=.005;i.gain.setValueAtTime(.001,V),i.gain.exponentialRampToValueAtTime(q,V+g),i.gain.setValueAtTime(q,V+e-g),i.gain.exponentialRampToValueAtTime(.001,V+e),t.start(V),t.stop(V+e),t.onended=()=>{t.disconnect(),i.disconnect()}}}async function playSteam(A=5,q=.7,e=1,t=1){let o=await decodeImpulseDataIfNeeded();for(let a=0;a<t;a++)setTimeout((function(){const t=audioContext.createOscillator(),a=audioContext.createGain(),n=audioContext.createGain(),i=audioContext.createBufferSource(),V=audioContext.createBuffer(1,audioContext.sampleRate,audioContext.sampleRate),g=audioContext.createConvolver();let s=V.getChannelData(0);for(let A=0;A<s.length;A++)s[A]=2*Math.random()-1;g.buffer=o,t.frequency.setValueAtTime(A,audioContext.currentTime),t.connect(a),a.connect(n),n.connect(g),g.connect(audioContext.destination),t.start(),t.stop(audioContext.currentTime+e),n.gain.setValueAtTime(0,audioContext.currentTime),n.gain.linearRampToValueAtTime(q,audioContext.currentTime+.5*e),n.gain.linearRampToValueAtTime(.001,audioContext.currentTime+e),a.gain.setValueAtTime(q,audioContext.currentTime),a.gain.exponentialRampToValueAtTime(.001,audioContext.currentTime+e),i.buffer=V,i.connect(a),i.start(),i.stop(audioContext.currentTime+e)}),a*e*1e3)}async function playAxeSound(A=300,q=.5,e=1,t=1){const o=await decodeImpulseDataIfNeeded();for(let a=0;a<t;a++)setTimeout((function(){const t=audioContext.createOscillator(),a=audioContext.createGain(),n=audioContext.createBufferSource(),i=audioContext.createBuffer(1,audioContext.sampleRate,audioContext.sampleRate),V=audioContext.createConvolver();let g=i.getChannelData(0);for(let A=0;A<g.length;A++)g[A]=1*Math.random()-1;V.buffer=o,t.frequency.setValueAtTime(A,audioContext.currentTime),t.connect(a),a.connect(V),V.connect(masterGain).connect(bandpassFilter).connect(audioContext.destination),t.start(),t.stop(audioContext.currentTime+.7*e),a.gain.setValueAtTime(q,audioContext.currentTime),a.gain.exponentialRampToValueAtTime(.001,audioContext.currentTime+e),n.buffer=i,n.connect(a).connect(masterGain).connect(bandpassFilter).connect(audioContext.destination),n.start(),n.stop(audioContext.currentTime+.5*e)}),a*e*1e3)}function playAxeSoundShort(A=100,q=1){const e=audioContext.createOscillator(),t=audioContext.createGain(),o=audioContext.createBufferSource(),a=audioContext.createBuffer(1,.2*audioContext.sampleRate,audioContext.sampleRate);let n=a.getChannelData(0);for(let A=0;A<n.length;A++)n[A]=2*Math.random()-1;e.frequency.setValueAtTime(A,audioContext.currentTime),e.connect(t),t.connect(audioContext.destination),e.start(),e.stop(audioContext.currentTime+.1),t.gain.setValueAtTime(q,audioContext.currentTime),t.gain.exponentialRampToValueAtTime(.001,audioContext.currentTime+.1),o.buffer=a,o.connect(t),o.start(),o.stop(audioContext.currentTime+.1)}function generateReverbImpulseResponse(A,q,e){const t=A.sampleRate*q,o=A.createBuffer(2,t,A.sampleRate),a=o.getChannelData(0),n=o.getChannelData(1);for(let q=0;q<t;q++){const t=500*Math.random()+100;a[q]=Math.sin(2*Math.PI*q*t/A.sampleRate)*e,n[q]=a[q];const o=Math.exp(-q/(.5*A.sampleRate));a[q]*=o,n[q]*=o}return o}function generateBreakingGlassSound(A){const q=20*A.sampleRate,e=A.createBuffer(1,q,A.sampleRate),t=e.getChannelData(0);for(let e=0;e<q;e++){t[e]=.2*(5*Math.random()-1);const q=1e3*Math.random()+10;t[e]+=.1*Math.sin(1.5*Math.PI*e*q/A.sampleRate);const o=Math.exp(-e/(.15*A.sampleRate));t[e]*=o}return e}async function applyReverb(A,q,e,t){const o=await getImpulseBuffer(reverbData),a=A.createConvolver();a.buffer=o;const n=A.createBufferSource();n.buffer=q,n.connect(a),a.connect(masterGain).connect(bandpassFilter).connect(A.destination),n.start()}function playExhaust(A=1,q=1){const e=generateBreakingGlassSound(audioContext);applyReverb(audioContext,e,A,q)}function playExhaust2(A=1,q=1){const e=generateBreakingGlassSound2(audioContext);applyReverb(audioContext,e,A,q)}function oldDropsRandom(){const A=[{of:10,ff:100},{of:10,ff:200},{of:50,ff:300},{of:50,ff:100},{of:100,ff:100},{of:200,ff:100},{of:1e3,ff:100},{of:1e4,ff:500},{of:2e4,ff:1e3}];let q=Math.floor(Math.random()*A.length);dropSoundOld(A[q].of,A[q].ff)}function dropSoundOld(A=10,q=100){const e=audioContext.createOscillator(),t=audioContext.createGain(),o=audioContext.createBiquadFilter();e.type=\"sawtooth\",e.frequency.value=A,o.type=\"lowpass\",o.frequency.value=q,e.frequency.exponentialRampToValueAtTime(100,audioContext.currentTime+.5),t.gain.setValueAtTime(1,audioContext.currentTime),t.gain.exponentialRampToValueAtTime(.001,audioContext.currentTime+1),e.connect(t).connect(o).connect(masterGain).connect(bandpassFilter).connect(audioContext.destination),e.start(),e.stop(audioContext.currentTime+1)}async function dropSound2(A=10,q=100,e=500,t=2,o=.1,a=.1){try{decodeBase64ToArrayBuffer(reverbData);const n=await decodeImpulseDataIfNeeded(),i=audioContext.createConvolver();if(i.buffer=n,A<0||A>22050)return;if(q<0||q>22050)return;if(e<0||e>22050)return;const V=audioContext.createOscillator(),g=audioContext.createGain(),s=audioContext.createBiquadFilter();V.type=\"sawtooth\",V.frequency.value=A,s.type=\"lowpass\",s.frequency.value=q,V.frequency.exponentialRampToValueAtTime(e,audioContext.currentTime+t),g.gain.setValueAtTime(.001,audioContext.currentTime),g.gain.linearRampToValueAtTime(a,audioContext.currentTime+.01),g.gain.setValueAtTime(a,audioContext.currentTime+o),g.gain.linearRampToValueAtTime(.001,audioContext.currentTime+2.99),g.connect(i).connect(masterGain).connect(bandpassFilter).connect(audioContext.destination),V.connect(g).connect(s).connect(masterGain).connect(bandpassFilter).connect(audioContext.destination),V.start(),V.stop(audioContext.currentTime+3)}catch(A){throw A}}let lfo1,modOsc1,stopEchoFXFadeFlag={};async function playEchoFX(A,q,e,t,o){const a=generateBreakingFX(audioContext);stopEchoFXFadeFlag[A]=!1,audioSources[A]=await applyFXWithPanningLoop(A,audioContext,a,q,e,t,o)}async function applyFXWithPanningLoop(A,q,e,t,o,a,n=1){const i=await decodeImpulseDataIfNeeded(),V=q.createConvolver();V.buffer=i;const g=q.createDelay();t=Math.min(Math.max(t,0),1),g.delayTime.value=t;const s=q.createGain();s.gain.value=o;const C=q.createStereoPanner();C.pan.value=a;const E=q.createBufferSource();E.buffer=e,E.connect(g),g.connect(s),s.connect(V).connect(C);const c=q.createGain();c.gain.value=n,C.connect(c),c.connect(masterGain).connect(bandpassFilter).connect(q.destination),g.connect(g),E.start();return E}function stopEchoFXFade(A){audioSources[A]&&audioSources[A].stop()}function generateBreakingFXSize(A,q=44100,e=1){const t=A.sampleRate,o=Math.ceil(q*e),a=A.createBuffer(1,o,q),n=a.getChannelData(0),i=t/q;for(let A=0;A<o;A++){const q=Math.floor(A*i);n[A]=.2*(10.15*Math.random()-.15);const e=10*Math.random()+10;n[A]+=.1*Math.sin(.5*Math.PI*q*e/t);const o=Math.exp(-q/(.05*t));n[A]*=o}return a}function generateBreakingFX(A){const q=30*A.sampleRate,e=A.createBuffer(1,q,A.sampleRate),t=e.getChannelData(0);for(let e=0;e<q;e++){t[e]=.2*(10.15*Math.random()-.15);const q=10*Math.random()+10;t[e]+=.1*Math.sin(.5*Math.PI*e*q/A.sampleRate);const o=Math.exp(-e/(.05*A.sampleRate));t[e]*=o}return e}function applyEchoWithPanning(A,q,e,t,o,a){const n=A.createDelay();n.delayTime.value=e;const i=A.createGain();i.gain.value=t;const V=A.createStereoPanner();V.pan.value=o;const g=A.createBufferSource();g.buffer=q,g.connect(n),n.connect(i),i.connect(V),V.connect(masterGain).connect(bandpassFilter).connect(A.destination),n.connect(n),g.start();const s=setInterval((()=>{V.pan.value=2*Math.random()-1}),a),C=()=>{clearInterval(s),g.disconnect(),n.disconnect(),i.disconnect(),V.disconnect()};g.onended=()=>{C(),!0===app.audio&&!1===holdOnSoundEvents&&playEcho(e,t,o,a)},g.onerror=C}function generateBreakingGlassSound2(A,q=44100){const e=A.sampleRate,t=Math.ceil(20*q),o=A.createBuffer(1,t,q),a=o.getChannelData(0),n=e/q*.15;for(let A=0;A<t;A++){const q=.2*(1*Math.random()-1),t=100*Math.random()+10,o=(q+.1*Math.sin(1*Math.PI*A*t/e))*Math.exp(-A/n);a[A]=o}return o}function playEcho(A,q,e,t){const o=generateBreakingGlassSound2(audioContext);applyEchoWithPanning(audioContext,o,A,q,e,t)}let lfo,modOsc,modulatorArgs=[[100,.03,20],[50,2,10],[120,3,10],[1.4,2e3,20],[2,5.2,50],[1,10,50],[.5,5,50],[4.6,16.6,50],[55.8,169,30],[428.7,19.1,30],[73.6,.5,30],[5.2,50.4,30]];function modulatorOldA(...A){let q=A[0],e=A[1],t=A[2];null!=lfo1&&lfo1.stop(),null!=modOsc1&&modOsc1.stop(),modOsc1=audioContext.createOscillator(),modOsc1.type=\"sine\",modOsc1.frequency.value=q,lfo1=audioContext.createOscillator(),lfo1.frequency.value=e;const o=audioContext.createGain();o.gain.value=t,lfo1.connect(o),o.connect(modOsc1.frequency),modOsc1.start(),lfo1.start(),modOsc1.connect(masterGain).connect(bandpassFilter).connect(audioContext.destination)}let whiteNoise,gainNode,isStarted=!1;function modulatorA(...A){let q=A[0],e=A[1],t=A[2];isStarted&&(lfo.stop(),modOsc.stop(),isStarted=!1),modOsc=audioContext.createOscillator(),modOsc.type=\"triangle\",modOsc.frequency.value=q,lfo=audioContext.createOscillator(),lfo.frequency.value=e;const o=audioContext.createGain();o.gain.value=t,lfo.connect(o),o.connect(modOsc.frequency),modOsc.start(),lfo.start(),isStarted=!0,modOsc.connect(masterGain).connect(bandpassFilter).connect(audioContext.destination)}function modulatorB(...A){let q=\"sine\",e=A[0],t=A[1],o=A[2];null!=A[4]&&(q=A[4]);let a=A[3]||.5;isStarted&&(lfo.stop(),modOsc.stop(),isStarted=!1),modOsc=audioContext.createOscillator(),modOsc.type=q,modOsc.frequency.value=e,lfo=audioContext.createOscillator(),lfo.frequency.value=t;const n=audioContext.createGain();n.gain.value=o;const i=audioContext.createGain();i.gain.value=a,lfo.connect(n),n.connect(modOsc.frequency),modOsc.connect(i),i.connect(masterGain).connect(bandpassFilter).connect(audioContext.destination),modOsc.start(),lfo.start(),isStarted=!0}let whiteNoiseFr=100,grow=0;function makeWhiteNoise(A,q,e){null==A&&(A=whiteNoiseFr),null!=whiteNoise&&whiteNoise.stop();const t=2*audioContext.sampleRate,o=audioContext.createBuffer(2,t,audioContext.sampleRate),a=o.getChannelData(0),n=o.getChannelData(1);for(let A=0;A<t;A++)a[A]=1.98*Math.random()-1,n[A]=1.98*Math.random()-1;const i=audioContext.createConvolver();i.buffer=o,whiteNoise=audioContext.createBufferSource();const V=2*audioContext.sampleRate,g=audioContext.createBuffer(2,V,audioContext.sampleRate),s=g.getChannelData(0),C=g.getChannelData(1);for(let A=0;A<V;A++)s[A]=2*Math.random()-1,C[A]=2*Math.random()-1;whiteNoise.buffer=g,whiteNoise.loop=!0,whiteNoise.playbackRate.value=A/audioContext.sampleRate,whiteNoise.connect(i);const E=audioContext.createGain();E.gain.value=q,E.connect(masterGain).connect(bandpassFilter).connect(audioContext.destination),i.connect(E);const c=audioContext.createGain();c.gain.value=e,c.connect(masterGain).connect(bandpassFilter).connect(audioContext.destination),whiteNoise.connect(whiteNoiseGain).connect(c),whiteNoise.start()}async function makeWhiteNoiseF(A,q,e,t,o){decodeBase64ToArrayBuffer(reverbData);const a=await decodeImpulseDataIfNeeded(),n=audioContext.createConvolver();n.buffer=a,void 0===A&&(A=whiteNoiseFr),void 0!==whiteNoise&&\"stopped\"!==whiteNoise.state&&whiteNoise.stop();const i=audioContext.sampleRate*t,V=audioContext.createBuffer(2,i,audioContext.sampleRate),g=V.getChannelData(0),s=V.getChannelData(1);for(let A=0;A<i;A++)g[A]=2*Math.random()-1,s[A]=2*Math.random()-1;whiteNoise=audioContext.createBufferSource(),whiteNoise.buffer=V,whiteNoise.loop=!0,whiteNoise.playbackRate.value=A/audioContext.sampleRate;const C=audioContext.createGain();C.gain.setValueAtTime(0,audioContext.currentTime),C.gain.linearRampToValueAtTime(q,audioContext.currentTime+o),C.gain.setValueAtTime(q,audioContext.currentTime+t-o),C.gain.linearRampToValueAtTime(0,audioContext.currentTime+t),whiteNoise.connect(C),C.connect(n).connect(masterGain).connect(audioContext.destination),whiteNoise.start(),whiteNoise.stop(audioContext.currentTime+t)}function findCharState(){[\"laying\",\"hunched\",\"meditating\",\"collapsed\",\"slouched\",\"sitting\",\"standing\"].map(((A,q)=>({id:q,name:";

  function getPart() external pure returns (string memory) {
    return PART;
  }
  
}