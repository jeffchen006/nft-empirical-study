/**
 *Submitted for verification at Etherscan.io on 2023-07-13
*/

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IUniswapV2Factory {
    function getPair(address tokenA, address tokenB) external view returns (address pair);
}

interface IUniswapV2Pair {
    function reserve0() external view returns (uint112);
    function reserve1() external view returns (uint112);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;
}

interface IUniswapV2Callee {
    function flashSwap(address sender, uint amount0, uint amount1, bytes calldata data) external returns (uint profit);
}

interface IERC20 {
    function totalSupply() external view returns (uint);

    function balanceOf(address account) external view returns (uint);

    function transfer(address recipient, uint amount) external returns (bool);

    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint amount
    ) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}

interface IWETH is IERC20 {
    function deposit() external payable;
    function withdraw(uint amount) external;
}

contract UniswapV2FlashSwap is IUniswapV2Callee {
    IUniswapV2Pair private immutable liquidityPair;
    address private constant UNISWAP_V2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;
    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    IUniswapV2Factory private factory;

    constructor(address pairAddress) {
        factory = IUniswapV2Factory(UNISWAP_V2_FACTORY);
        liquidityPair = IUniswapV2Pair(pairAddress);
    }
    
    // For this example, store the amount to repay
    uint public amountToRepay;
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;
    uint256 private _status;

    function owner() public view returns (address) {
        return msg.sender;
    }

      modifier nonReentrant() {
        uint256 status = _status; // Define a local variable to avoid overwriting storage
        
        require(status != _ENTERED, "ReentrancyGuard: reentrant call");

        _status = _ENTERED;
        
        _;
        
        _status = _NOT_ENTERED;
    }

    event FlashSwapInitiated(
        address indexed sender,
        uint amountWETH,
        uint amountDAI
    );

    function flashSwap(address caller, uint amount0Out, uint amount1Out, bytes calldata data) external override returns (uint profit) {
        // Get the WETH token contract
        IWETH weth = IWETH(WETH);

        // Get the DAI/WETH pair contract
        IUniswapV2Pair pair = IUniswapV2Pair(liquidityPair);

        // Get the amount of WETH that can be borrowed
        uint amount0 = pair.token0() == WETH ? pair.reserve0() : pair.reserve1();
        uint amount1 = pair.token1() == WETH ? pair.reserve0() : pair.reserve1();

        // about 0.3% fee, +1 to round up
        uint fee = (amount1 * 3) / 997 + 1;

        // Transfer flash swap fee from caller
        weth.transferFrom(caller, address(this), fee);

        // emit the FlashSwapInitiated event
        emit FlashSwapInitiated(msg.sender, amount0, amountToRepay);

        // Execute the flash swap
        pair.swap(amount0Out, amount1Out, address(this), data);
        profit = IERC20(WETH).balanceOf(address(this)) - amountToRepay;

        // Return the amount of profit that was generated by the flash swap
        return profit;
    }

    function depositProfit(address walletAddress, uint profit) internal {
        require(profit > 0, "The profit must be greater than 0");

        // Transfer the profit to the wallet using the `transfer` function to avoid front-running
        IERC20(WETH).transfer(walletAddress, profit);
    }

    function returnTokens(uint amount) internal {
        require(amount > 0, "The amount of tokens to be returned must be greater than 0");

        // Transfer the specified amount of tokens from the contract to the liquidity pool
        IERC20(DAI).transfer(address(liquidityPair), amount);
    }
}